(* ========================================================================== *)
(* FLOATING POINT DEFINITIONS                                                 *)
(* ========================================================================== *)

(* References:                                                                *)
(*                                                                            *)
(*  [ 1 ] John Harrison, "A Machine-Checked Theory of Floating Point          *)
(*        Arithmetic", from Lecture Notes in Computer Science, Vol. 1690,     *)
(*        September 1999.                                                     *)
(*  [ 2 ] David Goldberg, "What Every Computer Scientist Should Know About    *)
(*        Floating-Point Arithmetic", from Computing Surveys, March 1991      *)
(*        issue.                                                              *)
(*  [ 3 ] Nicholas Higham, "Accuracy and Stability of Numerical Algorithms",  *)
(*        Second Edition, 2002.                                               *)
(*  [ 4 ] IEEE 754 Standard for Floating Point Arithmetic, 2008.              *)
(*                                                                            *)
(* A large part of this formalization is taken from John Harrison's work.     *)

(* ========================================================================== *)

(* -------------------------------------------------------------------------- *)
(* Floating point format                                                      *)
(* -------------------------------------------------------------------------- *)

(* A floating point number is a real number that can be written as            *)
(*                                                                            *)
(*     +/- f * r^(e - p + 1)                                                  *)
(*                                                                            *)
(* where                                                                      *)
(*                                                                            *)
(*   -- f:num, r:num, e:int, p:num                                            *)
(*   -- 0 <= f < r^p                                                          *)
(*   -- r = radix; must be even integer > 1                                   *)
(*   -- p = precision > 0 (p = 0 is possible, but leads to messy edge cases   *)
(*      and is of little practical value)                                     *)
(*                                                                            *)
(* This formalization of floating point is more general, hence there is no    *)
(* restriction on the exponent.                                               *)

let is_valid_format = define
  `is_valid_format (r:num, p:num) = (1 < r /\ (EVEN r) /\ (0 < p))`;;

let fformat_typbij = new_type_definition
  "fformat"
  ("mk_fformat", "dest_fformat")
  (prove (`?(fmt:num#num). is_valid_format fmt`,
	  EXISTS_TAC `(2:num, 1:num)` THEN
	    REWRITE_TAC[is_valid_format] THEN
	    ARITH_TAC));;
			 
let fradix = define
  `fradix (fmt:fformat) = (FST (dest_fformat fmt))`;;

let fprec = define
  `fprec (fmt:fformat) = (SND (dest_fformat fmt))`;;

(* -------------------------------------------------------------------------- *)
(* Floating point numbers                                                     *)
(* -------------------------------------------------------------------------- *)

(* Define pow for integers, with same infix level and associativity.          *)
unparse_as_infix("ipow");;
let ipow = define
  `ipow (x:real) (e:int) = 
  (if (e < &0)
   then (inv (x pow (num_of_int (--e))))
   else (x pow (num_of_int e)))`;;
parse_as_infix("ipow",(24,"left"));;

(* frep = true if x is equal to the floating point representation given by    *)
(* fmt, f, and e.                                                             *)
let frep = define
  `frep (fmt:fformat) (f:num) (e:int) (x:real) = 
  ((f < (fradix fmt) EXP (fprec fmt)) /\ 
     (abs(x) = &f * &(fradix fmt) ipow (e - &(fprec fmt) + &1)))`;;
  
let is_float = define
  `is_float (fmt:fformat) (x:real) = (?(f:num) (e:int). (frep(fmt) f e x))`;;

(* -------------------------------------------------------------------------- *)
(* Normalized fractions / exponents                                           *)
(* -------------------------------------------------------------------------- *)

(* A fraction f is normalized when f >= r^(p - 1).                            *)
let is_norm_frac = define
  `is_norm_frac (fmt:fformat) (f:num) (x:real) = 
  (?(e:int). (frep(fmt) f e x) /\ 
     ((fradix fmt) EXP ((fprec fmt) - 1) <= f))`;;

let decode_norm_frac = define
  `decode_norm_frac (fmt:fformat) (x:real) =
  (@(f:num). is_norm_frac(fmt) f x)`;;

(* An exponent e is normalized when the corresponding f is normalized.        *)
let is_norm_exp = define
  `is_norm_exp (fmt:fformat) (e:int) (x:real) =
  (?(f:num). (frep(fmt) f e x) /\ 
     ((fradix fmt) EXP ((fprec fmt) - 1) <= f))`;;

let decode_norm_exp = define
  `decode_norm_exp (fmt:fformat) (x:real) =
  (@(e:int). is_norm_exp(fmt) e x)`;;

(* -------------------------------------------------------------------------- *)
(* Largest / smallest fp numbers, subject to conditions                       *)
(* -------------------------------------------------------------------------- *)

let is_largest = define
  `is_largest (fmt:fformat) (prop:real->bool) (fp:real)
  (is_float(fmt) fp /\ prop fp /\ 
     (!(fp':real). is_float(fmt) fp' /\ prop fp' ==> fp' <= fp)))`;;

let largest = define
  `largest (fmt:fformat) (prop:real->bool) = 
  (@(fp:real). is_largest(fmt) prop fp)

let is_smallest = define
  `is_smallest (fmt:fformat) (prop:real->bool) (fp:real)
  (is_float(fmt) fp /\ prop fp /\ 
     (!(fp':real). is_float(fmt) fp' /\ prop fp' ==> fp <= fp')))`;;

let smallest = define
  `smallest (fmt:fformat) (prop:real->bool) = 
  (@(fp:real). is_smallest(fmt) prop fp)

(* -------------------------------------------------------------------------- *)
(* Units in the last place (ULPs)                                             *)
(* -------------------------------------------------------------------------- *)

(* Definition: For any real non-zero x, _ulp(x)_ is the distance between the  *)
(* floating point numbers a, b such that a <= x < b. This will always be      *)
(* r^(e - p + 1) where e = normalized exponent of a.                          *)
let ulp = define
  `ulp (fmt:fformat) (x:real) =
  ((largest(fmt) (\fp. fp <= x)) - (smallest(fmt) (\fp. x < fp)))

(* -------------------------------------------------------------------------- *)
(* Rounding                                                                   *)
(* -------------------------------------------------------------------------- *)

let closer = define
  `closer (x:real) (y:real) (z:real) = (abs(x - z) < abs(y - z))`;;
  
let roundmode_INDUCT, roundmode_RECURSION = define_type
  "roundmode = To_near | To_zero | To_pinf | To_ninf";;

let round = define
  `((round (fmt:fformat) (To_near) (x:real) =
	(let lo = (smallest(fmt) (\fp. x <= fp))
	 and hi = (largest(fmt) (\fp. fp <= x))
	 in
	   (if closer lo hi x
	    then lo
	    else (if closer hi lo x
		  then hi
		  else (if EVEN (decode_norm_frac(fmt) lo)
			then lo
			else hi)))))
      
      (round (fmt:fformat) (To_zero) (x:real) =
	  (if (x > &0)
	   then (largest(fmt) (\fp. fp <= x))
	   else (smallest(fmt) (\fp. x <= fp))))

      (round (fmt:fformat) (To_pinf) (x:real) =
	  (smallest(fmt) (\fp. x <= fp)))

      (round (fmt:fformat) (To_ninf) (x:real) =
	  (largest(fmt) (\fp. fp <= x))))

(* -------------------------------------------------------------------------- *)
(* Relative Error                                                             *)
(* -------------------------------------------------------------------------- *)

let rerror = define
  `rerror (a:real) (b:real) = abs((b - a) / a)`;;

(* -------------------------------------------------------------------------- *)
(* Machine Epsilon                                                            *)
(* -------------------------------------------------------------------------- *)

(* Definition: For a fformat fmt, the _machine epsilon_ is                    *)
(*                                                                            *)
(*      eps = (2r^(p - 1) + 1)^(-1)                                           *)
(*                                                                            *)
(* It will be shown that for all x:real,                                      *)
(*                                                                            *)
(*      (rerror (round(fmt) To_near x) x) <= eps                              *)

let eps = define
  `eps (fmt:fformat) = (&1 / &(2 * (fradix fmt) EXP ((fprec fmt) - 1) + 1))`;;
