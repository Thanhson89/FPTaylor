(* ========================================================================== *)
(* FLOATING POINT DEFINITIONS                                                 *)
(* ========================================================================== *)

(* References:                                                                *)
(*                                                                            *)
(*  [ 1 ] John Harrison, "A Machine-Checked Theory of Floating Point          *)
(*        Arithmetic", from Lecture Notes in Computer Science, Vol. 1690,     *)
(*        September 1999.                                                     *)
(*  [ 2 ] David Goldberg, "What Every Computer Scientist Should Know About    *)
(*        Floating-Point Arithmetic", from Computing Surveys, March 1991      *)
(*        issue.                                                              *)
(*  [ 3 ] Nicholas Higham, "Accuracy and Stability of Numerical Algorithms",  *)
(*        Second Edition, 2002.                                               *)
(*  [ 4 ] IEEE 754 Standard for Floating Point Arithmetic, 2008.              *)

(* ========================================================================== *)

(* -------------------------------------------------------------------------- *)
(* Floating point format                                                      *)
(* -------------------------------------------------------------------------- *)

(* A floating point number is a real number that can be written as            *)
(*                                                                            *)
(*     +/- f * r^(e - p + 1)                                                  *)
(*                                                                            *)
(* where                                                                      *)
(*                                                                            *)
(*   -- f:num, r:num, e:num, p:num                                            *)
(*   -- 0 <= f < r^p                                                          *)
(*   -- emin <= e <= emax                                                     *)
(*   -- r = radix; must be even integer > 1                                   *)
(*   -- p = precision                                                         *)
(*   -- emin <= emax; minimum and maximum possible exponents, respectively    *)

let is_valid_format = define
  `is_valid_format (r:num, p:num, emin:num, emax:num) =
  (r > 1 /\
     (EVEN r) /\
     (emin <= emax))`;;

let fformat_typbij = new_type_definition
  "fformat"
  ("mk_fformat", "dest_fformat")
  (prove (`?(fmt:num#num#num#num). is_valid_format fmt`,
	  EXISTS_TAC `(2:num, 0:num, 0:num, 0:num)` THEN
	    REWRITE_TAC[is_valid_format] THEN
	    ARITH_TAC));;
			 
let fradix = define
  `fradix (fmt:fformat) = (FST (dest_fformat fmt))`;;

let fprec = define
  `fprec (fmt:fformat) = (FST (SND (dest_fformat fmt)))`;;

let femin = define
  `femin (fmt:fformat) = (FST (SND (SND (dest_fformat fmt))))`;;

let femax = define
  `femax (fmt:fformat) = (SND (SND (SND (dest_fformat fmt))))`;;

(* frep = true if x is equal to the floating point representation given by    *)
(* fmt, f, and e.                                                             *)
let frep = define
  `frep (fmt:fformat) (f:num) (e:num) (x:real) = 
  ((f < (fradix fmt) EXP (fprec fmt)) /\ 
     ((femin fmt) <= e) /\
     (e <= (femax fmt)) /\
     (abs(x) = &f * (&(fradix fmt) pow (e - (fprec fmt) + 1))))`;;
  
let is_float = define
  `is_float (fmt:fformat) (x:real) = (?(f:num) (e:num). (frep(fmt) f e x))`;;

(* -------------------------------------------------------------------------- *)
(* Types of floating point numbers                                            *)
(* -------------------------------------------------------------------------- *)

(* Although these definitions are intended to be general, it is worth noting  *)
(* that the IEEE 754 standard states that zero is neither normal nor          *)
(* denormal.                                                                  *)
(*                                                                            *)
(* The following is motivated by the definition in Goldberg.                  *)

let is_normal = define
  `is_normal (fmt:fformat) (x:real) =
  (?(f:num) (e:num).
     (frep(fmt) f e x) /\
     ((fradix fmt) EXP ((fprec fmt) - 1) <= f))`;;

let is_denormal = define
  `is_denormal (fmt:fformat) (x:real) =
  (~(x = 0) /\
     (?(f:num) (e:num).
	(frep(fmt) f e x) /\
	(f < (fradix fmt) EXP ((fprec fmt) - 1))))`;;
     
