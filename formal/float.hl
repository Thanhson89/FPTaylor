(* ========================================================================== *)
(* FLOATING POINT DEFINITIONS                                                 *)
(* ========================================================================== *)

(* References:                                                                *)
(*                                                                            *)
(*  [ 1 ] John Harrison, "A Machine-Checked Theory of Floating Point          *)
(*        Arithmetic", from Lecture Notes in Computer Science, Vol. 1690,     *)
(*        September 1999.                                                     *)
(*  [ 2 ] David Goldberg, "What Every Computer Scientist Should Know About    *)
(*        Floating-Point Arithmetic", from Computing Surveys, March 1991      *)
(*        issue.                                                              *)
(*  [ 3 ] Nicholas Higham, "Accuracy and Stability of Numerical Algorithms",  *)
(*        Second Edition, 2002.                                               *)
(*  [ 4 ] IEEE 754 Standard for Floating Point Arithmetic, 2008.              *)
(*                                                                            *)
(* A large part of this formalization is taken from John Harrison's work.     *)

(* ========================================================================== *)

(* -------------------------------------------------------------------------- *)
(* Floating point format                                                      *)
(* -------------------------------------------------------------------------- *)

(* A floating point number is a real number that can be written as            *)
(*                                                                            *)
(*     +/- f * r^(e - p + 1)                                                  *)
(*                                                                            *)
(* where                                                                      *)
(*                                                                            *)
(*   -- f:num, r:num, e:int, p:num                                            *)
(*   -- 0 <= f < r^p                                                          *)
(*   -- r = radix; must be even integer > 1                                   *)
(*   -- p = precision > 0 (p = 0 is possible, but leads to messy edge cases   *)
(*      and is of little practical value)                                     *)
(*                                                                            *)
(* This formalization of floating point is more general, hence there is no    *)
(* restriction on the exponent.                                               *)

let is_valid_format = define
  `is_valid_format (r:num, p:num) = (r > 1 /\ (EVEN r) /\ (p > 0))`;;

let fformat_typbij = new_type_definition
  "fformat"
  ("mk_fformat", "dest_fformat")
  (prove (`?(fmt:num#num). is_valid_format fmt`,
	  EXISTS_TAC `(2:num, 1:num)` THEN
	    REWRITE_TAC[is_valid_format] THEN
	    ARITH_TAC));;
			 
let fradix = define
  `fradix (fmt:fformat) = (FST (dest_fformat fmt))`;;

let fprec = define
  `fprec (fmt:fformat) = (SND (dest_fformat fmt))`;;

(* -------------------------------------------------------------------------- *)
(* Floating point numbers                                                     *)
(* -------------------------------------------------------------------------- *)

(* FIXME: How to convert from integers to naturals?                           *)
let num_of_int = define
  `num_of_int (i:int) = (@(n:num). &n = abs(i))`;;

(* Define pow for integers, with same infix level and associativity.          *)
unparse_as_infix("ipow");;
let ipow = define
  `ipow (x:real) (e:int) = 
  (if (e < &0)
   then (inv (x pow (num_of_int e)))
   else (x pow (num_of_int e)))`;;
parse_as_infix("ipow",(24,"left"));;

(* frep = true if x is equal to the floating point representation given by    *)
(* fmt, f, and e.                                                             *)
let frep = define
  `frep (fmt:fformat) (f:num) (e:int) (x:real) = 
  ((f < (fradix fmt) EXP (fprec fmt)) /\ 
     (abs(x) = &f * &(fradix fmt) ipow (e - &(fprec fmt) + &1)))`;;
  
let is_float = define
  `is_float (fmt:fformat) (x:real) = (?(f:num) (e:int). (frep(fmt) f e x))`;;

let decode_frac = define
  `decode_frac (fmt:fformat) (x:real) = 
  (@(f:num). (?(e:int). (frep(fmt) f e x)))`;;

let decode_exp = define
  `decode_exp (fmt:fformat) (x:real) = 
  (@(e:int). (?(f:num). (frep(fmt) f e x)))`;;

(* -------------------------------------------------------------------------- *)
(* Prev / floor / next / ceiling fp numbers                                   *)
(* -------------------------------------------------------------------------- *)

let is_closest = define
  `is_closest (fmt:fformat) (prop:real->bool) (x:real) (a:real) =
  (is_float(fmt) a /\
     prop a /\
     !(b:real). (is_float(fmt) b /\ prop b) ==> (abs(x - a) <= abs(x - b)))`;;

let is_closest_and = define
  `is_closest_and (fmt:fformat) (prop:real->bool) (prop2:real->bool)
  (x:real) (a:real) =
  (is_closest(fmt) prop x a /\
     !(b:real). is_closest(fmt) prop x b /\ prop2(b) ==> (a = b))`;;

(* prev_fp = the largest fp number y < x.                                     *)
let prev_fp = define
  `prev_fp (fmt:fformat) (x:real) = 
  (@(y:real). is_closest(fmt) (\z. z < x) x y)`;;

(* floor_fp = the largest fp number y <= x.                                   *)
let floor_fp = define
  `floor_fp (fmt:fformat) (x:real) = 
  (@(y:real). is_closest(fmt) (\z. z <= x) x y)`;;

(* next_fp = the smallest fp number y > x.                                    *)
let next_fp = define
  `next_fp (fmt:fformat) (x:real) = 
  (@(y:real). is_closest(fmt) (\z. z > x) x y)`;;

(* ceil_fp = the smallest fp number y >= x.                                   *)
let ceil_fp = define
  `ceil_fp (fmt:fformat) (x:real) = 
  (@(y:real). is_closest(fmt) (\z. x <= z) x y)`;;

(* -------------------------------------------------------------------------- *)
(* Units in the last place (ULPs)                                             *)
(* -------------------------------------------------------------------------- *)

(* Definition: For any real x, ulp(x) is the distance between the floating    *)
(* point numbers a, b such that a <= x < b. This will always be r^(e - p + 1) *)
(* where e = exponent of a.                                                   *)
let ulp = define
  `ulp (fmt:fformat) (x:real) =
  (@(u:real). (?(e:int). 
		(e = (decode_exp(fmt) (floor_fp(fmt) x)) /\
		    (u = (&(fradix fmt) ipow (e - &(fprec fmt) + &1))))))`;;

(* -------------------------------------------------------------------------- *)
(* Rounding                                                                   *)
(* -------------------------------------------------------------------------- *)

let roundmode_INDUCT, roundmode_RECURSION = define_type
  "roundmode = To_near | To_zero | To_pinf | To_ninf";;

let round = define
  `((round (fmt:fformat) (To_near) (x:real) =
	(@(a:real). (is_closest_and(fmt)
		       (\z. T)
		       (\z. EVEN (decode_frac(fmt) a))
		       x
		       a))) /\
      
      (round (fmt:fformat) (To_zero) (x:real) =
	  (if (x > &0)
	   then (floor_fp(fmt) x)
	   else (ceil_fp(fmt) x))) /\

      (round (fmt:fformat) (To_pinf) (x:real) = (ceil_fp(fmt) x)) /\

      (round (fmt:fformat) (To_ninf) (x:real) = (floor_fp(fmt) x)))`;;
