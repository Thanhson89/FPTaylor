(* ========================================================================== *)
(* FLOATING POINT DEFINITIONS                                                 *)
(* ========================================================================== *)

(* needs "common.hl";; *)
(* needs "fixed.hl";; *)

(* References:                                                                *)
(*                                                                            *)
(*  [ 1 ] John Harrison, "A Machine-Checked Theory of Floating Point          *)
(*        Arithmetic", from Lecture Notes in Computer Science, Vol. 1690,     *)
(*        September 1999.                                                     *)
(*  [ 2 ] David Goldberg, "What Every Computer Scientist Should Know About    *)
(*        Floating-Point Arithmetic", from Computing Surveys, March 1991      *)
(*        issue.                                                              *)
(*  [ 3 ] Nicholas Higham, "Accuracy and Stability of Numerical Algorithms",  *)
(*        Second Edition, 2002.                                               *)
(*  [ 4 ] IEEE 754 Standard for Floating Point Arithmetic, 2008.              *)
(*                                                                            *)
(* A large part of this formalization is based on John Harrison's work.       *)

(* ========================================================================== *)

(* -------------------------------------------------------------------------- *)
(* Floating point format                                                      *)
(* -------------------------------------------------------------------------- *)

(* Fix r:num > 1 and even, p:num > 0. A floating point number is a real       *)
(* number that can be written as                                              *)
(*                                                                            *)
(*     +/- f * r^(e - p + 1)                                                  *)
(*                                                                            *)
(* where                                                                      *)
(*                                                                            *)
(*   -- e is an integer                                                       *)
(*   -- 0 < f < r^p (so zero is not a floating point number)                  *)

let is_valid_flformat = define
  `is_valid_flformat (r:num, p:num) = (1 < r /\ (EVEN r) /\ (0 < p))`;;

let flformat_typbij = new_type_definition
  "flformat"
  ("mk_flformat", "dest_flformat")
  (prove (`?(fmt:num#num). is_valid_flformat fmt`,
	  EXISTS_TAC `(2:num, 1:num)` THEN
	    REWRITE_TAC[is_valid_flformat] THEN
	    ARITH_TAC));;

let flr = define
  `flr (fmt:flformat) = (FST (dest_flformat fmt))`;;

let flp = define
  `flp (fmt:flformat) = (SND (dest_flformat fmt))`;;

let is_frac_and_exp = define
  `is_frac_and_exp (fmt:flformat) (x:real) (f:num) (e:int) =
  (0 < f /\
   f < (flr fmt) EXP ((flp fmt) - 1) /\
   abs(x) = &f * &(flr fmt) ipow (e - &(flp fmt) + &1))`;;

let is_float = define
  `is_float (fmt:flformat) (x:real) = 
  (?(f:num) (e:int) . is_frac_and_exp(fmt) x f e)`;;

let to_fformat = define
  `to_fformat (fmt:flformat) (e:int) = (mk_fformat ((flr fmt), (flp fmt), e))`;;

(* -------------------------------------------------------------------------- *)
(* Normalization                                                              *)
(* -------------------------------------------------------------------------- *)

(* x = +/- m * r^e + y *)

let normalizes = define
  `normalizes (fmt:flformat) (x:real) (m:num) (e:int) (y:real) =
  (0 < m /\
   m < (flr fmt) /\
   abs(y) <= (finf (to_fformat fmt e)) /\
  (if (&0 <= x)
   then
     x = &m * &(flr fmt) ipow e + y
   else
     x = -- &m * &(flr fmt) ipow e + y))`;;

let greatest_e = define
  `greatest_e (fmt:flformat) (x:real) = 
  sup_int({ (z:int) | &(flr fmt) ipow z <= abs(x) })`;;

let greatest_m = define
  `greatest_m (fmt:flformat) (x:real) =
  sup_num({ (m:num) | &m * &(flr fmt) ipow (greatest_e(fmt) x) <= abs(x) })`;;

let greatest_r = define
  `greatest_r (fmt:flformat) (x:real) = 
  (if (&0 <= x)
   then 
     (x - &(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x))
   else 
     (x + &(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x)))`;;

(* -------------------------------------------------------------------------- *)
(* Rounding                                                                   *)
(* -------------------------------------------------------------------------- *)

let flround = define
  `flround (fmt:flformat) (mode:roundmode) (x:real) =
  (let m = (greatest_m(fmt) x)
   and e = (greatest_e(fmt) x)
   and y = (greatest_r(fmt) x)
   in
     (if (&0 <= x)
      then
     	(&m * &(flr fmt) ipow e +
     	   (fround(to_fformat fmt e) mode y))
      else
     	(-- (&m * &(flr fmt) ipow e) +
     	   (fround(to_fformat fmt e) mode y))))`;;

(* -------------------------------------------------------------------------- *)
(* Machine Epsilon                                                            *)
(* -------------------------------------------------------------------------- *)

(* Definition: For a flformat fmt, the _machine epsilon_ is                   *)
(*                                                                            *)
(*      fleps = (2r^(p - 1) + 1)^(-1)                                         *)
(* let fleps = define *)
(*   `fleps (fmt:flformat) = (&1 / &(2 * (flr fmt) EXP ((flp fmt) - 1) + 1))`;; *)
