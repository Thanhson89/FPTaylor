(* ========================================================================== *)
(* FLOATING POINT DEFINITIONS                                                 *)
(* ========================================================================== *)

(* References:                                                                *)
(*                                                                            *)
(*  [ 1 ] John Harrison, "A Machine-Checked Theory of Floating Point          *)
(*        Arithmetic", from Lecture Notes in Computer Science, Vol. 1690,     *)
(*        September 1999.                                                     *)
(*  [ 2 ] David Goldberg, "What Every Computer Scientist Should Know About    *)
(*        Floating-Point Arithmetic", from Computing Surveys, March 1991      *)
(*        issue.                                                              *)
(*  [ 3 ] Nicholas Higham, "Accuracy and Stability of Numerical Algorithms",  *)
(*        Second Edition, 2002.                                               *)
(*  [ 4 ] IEEE 754 Standard for Floating Point Arithmetic, 2008.              *)

(* ========================================================================== *)

(* -------------------------------------------------------------------------- *)
(* Floating point format                                                      *)
(* -------------------------------------------------------------------------- *)

(* A floating point number is a real number that can be written as            *)
(*                                                                            *)
(*     +/- f * r^(e - p + 1)                                                  *)
(*                                                                            *)
(* where                                                                      *)
(*                                                                            *)
(*   -- f:num, r:num, e:num, p:num                                            *)
(*   -- 0 <= f < r^p                                                          *)
(*   -- emin <= e <= emax                                                     *)
(*   -- r = radix; must be even integer > 1                                   *)
(*   -- p = precision > 0 (p = 0 is possible, but leads to messy edge cases   *)
(*      and is of little practical value)                                     *)
(*   -- emin <= emax; minimum and maximum possible exponents, respectively    *)

let is_valid_format = define
  `is_valid_format (r:num, p:num, emin:num, emax:num) =
  (r > 1 /\
     (EVEN r) /\
     (p > 0) /\
     (emin <= emax))`;;

let fformat_typbij = new_type_definition
  "fformat"
  ("mk_fformat", "dest_fformat")
  (prove (`?(fmt:num#num#num#num). is_valid_format fmt`,
	  EXISTS_TAC `(2:num, 1:num, 0:num, 0:num)` THEN
	    REWRITE_TAC[is_valid_format] THEN
	    ARITH_TAC));;
			 
let fradix = define
  `fradix (fmt:fformat) = (FST (dest_fformat fmt))`;;

let fprec = define
  `fprec (fmt:fformat) = (FST (SND (dest_fformat fmt)))`;;

let femin = define
  `femin (fmt:fformat) = (FST (SND (SND (dest_fformat fmt))))`;;

let femax = define
  `femax (fmt:fformat) = (SND (SND (SND (dest_fformat fmt))))`;;

(* frep = true if x is equal to the floating point representation given by    *)
(* fmt, f, and e.                                                             *)
let frep = define
  `frep (fmt:fformat) (f:num) (e:num) (x:real) = 
  ((f < (fradix fmt) EXP (fprec fmt)) /\ 
     ((femin fmt) <= e) /\
     (e <= (femax fmt)) /\
     (abs(x) = &f * 
	 &(fradix fmt) pow (e + 1) / &(fradix fmt) pow (fprec fmt)))`;;
  
let is_float = define
  `is_float (fmt:fformat) (x:real) = (?(f:num) (e:num). (frep(fmt) f e x))`;;

(* -------------------------------------------------------------------------- *)
(* Types of floating point numbers                                            *)
(* -------------------------------------------------------------------------- *)

(* Although these definitions are intended to be general, it is worth noting  *)
(* that the IEEE 754 standard states that zero is neither normal nor          *)
(* denormal.                                                                  *)
(*                                                                            *)
(* The following definition is motivated by the IEEE 754 standard and John    *)
(* Harrison's `normalises' and `tiny'.                                        *)
(*                                                                            *)
(* Definition: A _normal_ fp number is an fp number whose magnitude           *)
(* is >= r^(emin).                                                            *)
(*                                                                            *)
(* Definition: A _denormal_ fp number is a *non-zero* fp number whose         *)
(* magnitudue < r^(emin).                                                     *)
(*                                                                            *)
(* Note: When the precision is 1, there are normal fp numbers but no denormal *)
(* fp numbers.                                                                *)
(*                                                                            *)
(* Definition: A _binade boundary_ is an fp number whose magnitude = r^e for  *)
(* emin <= e <= emax.                                                         *)
(*                                                                            *)
(* Note: All binade boundaries are normal fp numbers.                         *)
(*                                                                            *)
(* Definition: A _binade_ is an interval of real numbers [x, y] such that     *)
(* -- x is a binade boundary, and hence |x| = r^e for emin <= e <= emax       *)
(* -- |y| = r^(e + 1)                                                         *)
(*                                                                            *)
(* Note: In the final binade (when |x| = r^emax), |y| = r^(emax + 1), and is  *)
(* hence not an fp number.                                                    *)

let is_normal = define
  `is_normal (fmt:fformat) (x:real) =
  (is_float(fmt) x /\
     (&(fradix fmt) pow (femin fmt)) <= abs(x))`;;

let is_denormal = define
  `is_denormal (fmt:fformat) (x:real) =
  (~(x = &0) /\
     is_float(fmt) x /\
     (abs(x) < &(fradix fmt) pow (femin fmt)))`;;
     
let is_binade_bdry = define
  `is_binade_bdry (fmt:fformat) (x:real) =
  (?(f:num) (e:num).
     (frep(fmt) f e x) /\ 
     f = ((fradix fmt) EXP (fprec fmt)) DIV (fradix fmt))`;;

(* The largest fp number for a format = (r^p - 1) * r^(emax - p + 1).         *)
let flargest = define
  `flargest (fmt:fformat) = 
  (@(x:real). (?(f:num) (e:num).
		 (frep(fmt) f e x) /\
		 (e = (femax fmt)) /\
		 (f = (fradix fmt) EXP (fprec fmt) - 1)))`;;

(* -------------------------------------------------------------------------- *)
(* Units in the last place (ULPs)                                             *)
(* -------------------------------------------------------------------------- *)

(* Compared to other formalizations, ULPs play a smaller role in our          *)
(* formalization. ULPs are only defined for *fp numbers* and measure what the *)
(* words `units in the last place' mean:                                      *)
(*                                                                            *)
(* Definition: Given a fformat fmt with precision > 0 and an fp number x in   *)
(* this format with                                                           *)
(*                                                                            *)
(*          |x| = f * r^(e - p + 1)                                           *)
(*                                                                            *)
(* ulp(x) = r^(e - p + 1).                                                    *)
(*                                                                            *)
(* Note: Machine epsilon (defined below) will be used for measuring error.    *)

let ulp = define
  `ulp (fmt:fformat) (x:real) =
  (@(u:num)

