(* ========================================================================== *)
(* FLOATING POINT DEFINITIONS                                                 *)
(* ========================================================================== *)

(* References:                                                                *)
(*                                                                            *)
(*  [ 1 ] John Harrison, "A Machine-Checked Theory of Floating Point          *)
(*        Arithmetic", from Lecture Notes in Computer Science, Vol. 1690,     *)
(*        September 1999.                                                     *)
(*  [ 2 ] David Goldberg, "What Every Computer Scientist Should Know About    *)
(*        Floating-Point Arithmetic", from Computing Surveys, March 1991      *)
(*        issue.                                                              *)
(*  [ 3 ] Nicholas Higham, "Accuracy and Stability of Numerical Algorithms",  *)
(*        Second Edition, 2002.                                               *)
(*  [ 4 ] IEEE 754 Standard for Floating Point Arithmetic, 2008.              *)
(*                                                                            *)
(* A large part of this formalization is based on John Harrison's work.       *)

(* ========================================================================== *)

(* -------------------------------------------------------------------------- *)
(* Floating point format                                                      *)
(* -------------------------------------------------------------------------- *)

(* Fix r:num > 1 and even, p:num > 0. A floating point number is a real       *)
(* number that can be written as                                              *)
(*                                                                            *)
(*     +/- (m * r^e + y)                                                      *)
(*                                                                            *)
(* where                                                                      *)
(*                                                                            *)
(*   -- e is an integer                                                       *)
(*   -- y is a fixed point number with exponent e, radix r, and precision p   *)
(*   -- m is a natural number (short for most significant digit) with         *)
(*      0 < m < r (notice for r = 2, m is always 1)                           *)
(*                                                                            *)
(* There is no restriction on the exponent (makes the formalization more      *)
(* general).                                                                  *)
(*                                                                            *)
(* An alternative representation for floating point numbers is                *)
(*                                                                            *)
(*   +/- f * r^(e - p + 1)                                                    *)
(*                                                                            *)
(* where 0 <= f < r^p. The fraction is normalized when r^(p - 1) <= f < r^p.  *)
(* Suppose |x| = f * r^(e - p + 1) with f normalized; then                    *)
(*                                                                            *)
(*   f = m * r^(p - 1) + B * r^(p - 2) + C * r^(p - 3) + ...                  *)
(*                                                                            *)
(* with 0 < m < r. It then follows that                                       *)
(*                                                                            *)
(*   f * r^(e - p + 1) = m * r^e + (B * r^(p - 2) + ...) * r^(e - p + 1)      *)
(*                     = m * r^e + f' * r^(e - p + 1)                         *)
(*                     = m * r^e + y                                          *)
(*                                                                            *)
(* Notice that 0 <= f' < r^(p - 1), so y is a fixed point number with radix   *)
(* r, precision p, and exponent e. This shows any floating point number in    *)
(* the common format can be written in our format, and moreover, that the     *)
(* corresponding exponent e in our format is always normalized.               *)

let is_valid_flformat = define
  `is_valid_flformat (r:num, p:num) = (1 < r /\ (EVEN r) /\ (0 < p))`;;

let flformat_typbij = new_type_definition
  "flformat"
  ("mk_flformat", "dest_flformat")
  (prove (`?(fmt:num#num). is_valid_flformat fmt`,
	  EXISTS_TAC `(2:num, 1:num)` THEN
	    REWRITE_TAC[is_valid_flformat] THEN
	    ARITH_TAC));;

let flr = define
  `flr (fmt:flformat) = (FST (dest_flformat fmt))`;;

let flp = define
  `flp (fmt:fformat) = (SND (dest_flformat fmt))`;;

let is_msd_and_exp = define
  `is_msd_and_exp (fmt:flformat) (x:real) (m:num) (e:int) =
  (?(y:real) . ((is_fixed((flr(fmt), flp(fmt), e)) y) /\
		  x = &m * &(flr fmt) ipow e + y))`;;

let flm = define
  `flm (fmt:flformat) (x:real) =
  (@(m:num) . ?:(e:int) . is_msd_and_exp(fmt) x m e)`;;

let fle = define
  `fle (fmt:flformat) (x:real) =
  (@(e:int) . ?:(m:num) . is_msd_and_exp(fmt) x m e)`;;

let is_float = define
  `is_float (fmt:flformat) (x:real) = 
  (?(m:num) (e:int) . is_msd_and_exp(fmt) x m e)`;;

(* -------------------------------------------------------------------------- *)
(* Rounding                                                                   *)
(* -------------------------------------------------------------------------- *)

let greatest_exp = define
  `greatest_exp (fmt:flformat) (x:real) = 
  sup({ (z:int) | &(flr fmt) ipow z <= |x| })`;;

let greatest_msd = define
  `greatest_msd (fmt:flformat) (x:real) =
  sup({ (m:num) | (m * (greatest_exp(fmt) x) <= |x| /\ 
		       1 < m /\ 
		       m < (flr fmt))})`;;

let greatest_rem = define
  `greatest_rem (fmt:flformat) (x:real) = 
  (x - (greatest_msd(fmt) x) * &(flr fmt) ipow (greatest_exp(fmt) x))`;;

let flround = define
  `flround (fmt:flformat) (mode:roundmode) (x:real) =
  (let m = (greatest_msd(fmt) x)
   and e = (greatest_exp(fmt) x)
   and y = (greatest_rem(fmt) x)
   in
     (if (&0 < x)
      then
	(m * &(flr fmt) ipow e + 
	   (fround((flr fmt), (flp fmt), e) mode y))
      else
	(-- m * &(flr fmt) ipow e + 
	   (fround((flr fmt), (flp fmt), e) mode y))))`;;

(* -------------------------------------------------------------------------- *)
(* Machine Epsilon                                                            *)
(* -------------------------------------------------------------------------- *)

(* Definition: For a flformat fmt, the _machine epsilon_ is                   *)
(*                                                                            *)
(*      fleps = (2r^(p - 1) + 1)^(-1)                                         *)
let fleps = define
  `fleps (fmt:flformat) = (&1 / &(2 * (flr fmt) EXP ((flp fmt) - 1) + 1))`;;
