(* ========================================================================== *)
(* FLOATING POINT DEFINITIONS                                                 *)
(* ========================================================================== *)

(* References:                                                                *)
(*                                                                            *)
(*  [ 1 ] John Harrison, "A Machine-Checked Theory of Floating Point          *)
(*        Arithmetic", from Lecture Notes in Computer Science, Vol. 1690,     *)
(*        September 1999.                                                     *)
(*  [ 2 ] David Goldberg, "What Every Computer Scientist Should Know About    *)
(*        Floating-Point Arithmetic", from Computing Surveys, March 1991      *)
(*        issue.                                                              *)
(*  [ 3 ] Nicholas Higham, "Accuracy and Stability of Numerical Algorithms",  *)
(*        Second Edition, 2002.                                               *)
(*  [ 4 ] IEEE 754 Standard for Floating Point Arithmetic, 2008.              *)
(*                                                                            *)
(* A large part of this formalization is taken from John Harrison's work.     *)

(* ========================================================================== *)

(* -------------------------------------------------------------------------- *)
(* Floating point format                                                      *)
(* -------------------------------------------------------------------------- *)

(* A floating point number is a real number that can be written as            *)
(*                                                                            *)
(*     +/- f * r^(e - p + 1)                                                  *)
(*                                                                            *)
(* where                                                                      *)
(*                                                                            *)
(*   -- f:num, r:num, e:int, p:num                                            *)
(*   -- 0 <= f < r^p                                                          *)
(*   -- r = radix; must be even integer > 1                                   *)
(*   -- p = precision > 0 (p = 0 is possible, but leads to messy edge cases   *)
(*      and is of little practical value)                                     *)
(*                                                                            *)
(* This formalization of floating point is more general, hence there is no    *)
(* restriction on the exponent.                                               *)

let is_valid_format = define
  `is_valid_format (r:num, p:num) = (r > 1 /\ (EVEN r) /\ (p > 0))`;;

let fformat_typbij = new_type_definition
  "fformat"
  ("mk_fformat", "dest_fformat")
  (prove (`?(fmt:num#num). is_valid_format fmt`,
	  EXISTS_TAC `(2:num, 1:num)` THEN
	    REWRITE_TAC[is_valid_format] THEN
	    ARITH_TAC));;
			 
let fradix = define
  `fradix (fmt:fformat) = (FST (dest_fformat fmt))`;;

let fprec = define
  `fprec (fmt:fformat) = (SND (dest_fformat fmt))`;;

(* -------------------------------------------------------------------------- *)
(* Floating point numbers                                                     *)
(* -------------------------------------------------------------------------- *)

(* frep = true if x is equal to the floating point representation given by    *)
(* fmt, f, and e.                                                             *)
let frep = define
  `frep (fmt:fformat) (f:num) (e:int) (x:real) = 
  ((f < (fradix fmt) EXP (fprec fmt)) /\ 
     (abs(x) = &f * &(fradix fmt) pow (e - (fprec fmt) + 1)))`;;
  
let is_float = define
  `is_float (fmt:fformat) (x:real) = (?(f:num) (e:int). (frep(fmt) f e x))`;;

let decode_frac = define
  `decode_frac (fmt:fformat) (x:real) = 
  (@(f:num). (?(e:int). (frep(fmt) f e x)))`;;

let decode_exp = define
  `decode_frac (fmt:fformat) (x:real) = 
  (@(e:int). (?(f:num). (frep(fmt) f e x)))`;;

(* -------------------------------------------------------------------------- *)
(* Prev / floor / next / ceiling fp numbers                                   *)
(* -------------------------------------------------------------------------- *)

let is_closest = define
  `is_closest (fmt:fformat) (prop:real->bool) (x:real) (a:real) =
  (is_float(fmt) a /\
     prop a /\
     !(b:real). (is_float(fmt) b /\ prop b) ==> (abs(x - a) <= abs(x - b)))`;;

(* prev_fp = the largest fp number y < x.                                     *)
let prev_fp = define
  `prev_fp (fmt:fformat) (x:real) = 
  (@(y:real). is_closest(fmt) (\z. z < x) x y)`;;

(* floor_fp = the largest fp number y <= x.                                   *)
let floor_fp = define
  `floor_fp (fmt:fformat) (x:real) = 
  (@(y:real). is_closest(fmt) (\z. z <= x) x y)`;;

(* next_fp = the smallest fp number y > x.                                    *)
let next_fp = define
  `next_fp (fmt:fformat) (x:real) = 
  (@(y:real). is_closest(fmt) (\z. z > x) x y)`;;

(* ceil_fp = the smallest fp number y >= x.                                   *)
let ceil_fp = define
  `ceil_fp (fmt:fformat) (x:real) = 
  (@(y:real). is_closest(fmt) (\z. x <= z) x y)`;;

(* -------------------------------------------------------------------------- *)
(* Units in the last place (ULPs)                                             *)
(* -------------------------------------------------------------------------- *)

(* Definition: For any real x, ulp(x) is the distance between the floating    *)
(* point numbers a, b such that a <= x < b. This will always be r^(e - p + 1) *)
(* where e = exponent of a.                                                   *)
let ulp = define
  `ulp (fmt:fformat) (x:real) =
  (@(u:num). (?(e:int). 
		(e = (decode_exp(fmt) (floor_fp(fmt) x)) /\
		    (u = ((fradix fmt) EXP (e + 1)) DIV 
			((fradix fmt) EXP (fprec fmt))))))`;;

(* -------------------------------------------------------------------------- *)
(* Rounding                                                                   *)
(* -------------------------------------------------------------------------- *)

let roundmode_INDUCT, roundmode_RECURSION = define_type
  "roundmode = To_near | To_zero | To_pinf | To_ninf";;
