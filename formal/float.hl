(* ========================================================================== *)
(* FLOATING POINT DEFINITIONS                                                 *)
(* ========================================================================== *)

(* References:                                                                *)
(*                                                                            *)
(*  [ 1 ] John Harrison, "A Machine-Checked Theory of Floating Point          *)
(*        Arithmetic", from Lecture Notes in Computer Science, Vol. 1690,     *)
(*        September 1999.                                                     *)
(*  [ 2 ] David Goldberg, "What Every Computer Scientist Should Know About    *)
(*        Floating-Point Arithmetic", from Computing Surveys, March 1991      *)
(*        issue.                                                              *)
(*  [ 3 ] Nicholas Higham, "Accuracy and Stability of Numerical Algorithms",  *)
(*        Second Edition, 2002.                                               *)
(*  [ 4 ] IEEE 754 Standard for Floating Point Arithmetic, 2008.              *)
(*                                                                            *)
(* A large part of this formalization is based on John Harrison's work.       *)

(* ========================================================================== *)

(* -------------------------------------------------------------------------- *)
(* Floating point format                                                      *)
(* -------------------------------------------------------------------------- *)

(* Fix r:num > 1 and even, p:num > 0. A floating point number is a real       *)
(* number that can be written as                                              *)
(*                                                                            *)
(*     +/- (m * r^e + y)                                                      *)
(*                                                                            *)
(* where                                                                      *)
(*                                                                            *)
(*   -- e is an integer                                                       *)
(*   -- y is a fixed point number with exponent e, radix r, and precision p   *)
(*   -- m is a natural number (short for most significant digit) with         *)
(*      0 < m < r (notice for r = 2, m is always 1)                           *)
(*                                                                            *)
(* There is no restriction on the exponent (makes the formalization more      *)
(* general).                                                                  *)
(*                                                                            *)
(* An alternative representation for floating point numbers is                *)
(*                                                                            *)
(*   +/- f * r^(e - p + 1)                                                    *)
(*                                                                            *)
(* where 0 <= f < r^p. The fraction is normalized when r^(p - 1) <= f < r^p.  *)
(* Suppose |x| = f * r^(e - p + 1) with f normalized; then                    *)
(*                                                                            *)
(*   f = m * r^(p - 1) + B * r^(p - 2) + C * r^(p - 3) + ...                  *)
(*                                                                            *)
(* with 0 < m < r. It then follows that                                       *)
(*                                                                            *)
(*   f * r^(e - p + 1) = m * r^e + (B * r^(p - 2) + ...) * r^(e - p + 1)      *)
(*                     = m * r^e + f' * r^(e - p + 1)                         *)
(*                     = m * r^e + y                                          *)
(*                                                                            *)
(* Notice that 0 <= f' < r^(p - 1), so y is a fixed point number with radix   *)
(* r, precision p, and exponent e. This shows any floating point number in    *)
(* the common format can be written in our format, and moreover, that the     *)
(* corresponding exponent e in our format is always normalized.               *)

let is_valid_flformat = define
  `is_valid_flformat (r:num, p:num) = (1 < r /\ (EVEN r) /\ (0 < p))`;;

let flformat_typbij = new_type_definition
  "flformat"
  ("mk_flformat", "dest_flformat")
  (prove (`?(fmt:num#num). is_valid_flformat fmt`,
	  EXISTS_TAC `(2:num, 1:num)` THEN
	    REWRITE_TAC[is_valid_flformat] THEN
	    ARITH_TAC));;

let flr = define
  `flr (fmt:flformat) = (FST (dest_flformat fmt))`;;

let flp = define
  `flp (fmt:fformat) = (SND (dest_flformat fmt))`;;

let is_msd_and_exp = define
  `is_exp (fmt:flformat) (x:real) (m:num) (e:int) =
  (?(y:real) . ((is_fixed((flr(fmt), flp(fmt), e)) y) /\
		  x = &m * &(flr fmt) ipow e + y))`;;

let flm = define
  `flm (fmt:flformat) (x:real) =
  (@(m:num) . ?:(e:int) . is_msd_and_exp(fmt) x m e)`;;

let fle = define
  `fle (fmt:flformat) (x:real) =
  (@(e:int) . ?:(m:num) . is_msd_and_exp(fmt) x m e)`;;

let is_float = define
  `is_float (fmt:flformat) (x:real) = 
  (?(m:num) (e:int) . is_msd_and_exp(fmt) x m e)`;;

(* -------------------------------------------------------------------------- *)
(* Largest / smallest fp numbers, subject to conditions                       *)
(* -------------------------------------------------------------------------- *)

let is_largest = define
  `is_largest (fmt:fformat) (prop:real->bool) (fp:real)
  (is_float(fmt) fp /\ prop fp /\ 
     (!(fp':real). is_float(fmt) fp' /\ prop fp' ==> fp' <= fp)))`;;

let largest = define
  `largest (fmt:fformat) (prop:real->bool) = 
  (@(fp:real). is_largest(fmt) prop fp)

let is_smallest = define
  `is_smallest (fmt:fformat) (prop:real->bool) (fp:real)
  (is_float(fmt) fp /\ prop fp /\ 
     (!(fp':real). is_float(fmt) fp' /\ prop fp' ==> fp <= fp')))`;;

let smallest = define
  `smallest (fmt:fformat) (prop:real->bool) = 
  (@(fp:real). is_smallest(fmt) prop fp)

(* -------------------------------------------------------------------------- *)
(* Units in the last place (ULPs)                                             *)
(* -------------------------------------------------------------------------- *)

(* Definition: For any real non-zero x, _ulp(x)_ is the distance between the  *)
(* floating point numbers a, b such that a <= x < b. This will always be      *)
(* r^(e - p + 1) where e = normalized exponent of a.                          *)
let ulp = define
  `ulp (fmt:fformat) (x:real) =
  ((largest(fmt) (\fp. fp <= x)) - (smallest(fmt) (\fp. x < fp)))

(* -------------------------------------------------------------------------- *)
(* Rounding                                                                   *)
(* -------------------------------------------------------------------------- *)

let closer = define
  `closer (x:real) (y:real) (z:real) = (abs(x - z) < abs(y - z))`;;
  
let roundmode_INDUCT, roundmode_RECURSION = define_type
  "roundmode = To_near | To_zero | To_pinf | To_ninf";;

let round = define
  `((round (fmt:fformat) (To_near) (x:real) =
	(let lo = (smallest(fmt) (\fp. x <= fp))
	 and hi = (largest(fmt) (\fp. fp <= x))
	 in
	   (if closer lo hi x
	    then lo
	    else (if closer hi lo x
		  then hi
		  else (if EVEN (decode_norm_frac(fmt) lo)
			then lo
			else hi)))))
      
      (round (fmt:fformat) (To_zero) (x:real) =
	  (if (x > &0)
	   then (largest(fmt) (\fp. fp <= x))
	   else (smallest(fmt) (\fp. x <= fp))))

      (round (fmt:fformat) (To_pinf) (x:real) =
	  (smallest(fmt) (\fp. x <= fp)))

      (round (fmt:fformat) (To_ninf) (x:real) =
	  (largest(fmt) (\fp. fp <= x))))

(* -------------------------------------------------------------------------- *)
(* Relative Error                                                             *)
(* -------------------------------------------------------------------------- *)

let rerror = define
  `rerror (a:real) (b:real) = abs((b - a) / a)`;;

(* -------------------------------------------------------------------------- *)
(* Machine Epsilon                                                            *)
(* -------------------------------------------------------------------------- *)

(* Definition: For a fformat fmt, the _machine epsilon_ is                    *)
(*                                                                            *)
(*      eps = (2r^(p - 1) + 1)^(-1)                                           *)
(*                                                                            *)
(* It will be shown that for all x:real,                                      *)
(*                                                                            *)
(*      (rerror (round(fmt) To_near x) x) <= eps                              *)

let eps = define
  `eps (fmt:fformat) = (&1 / &(2 * (fradix fmt) EXP ((fprec fmt) - 1) + 1))`;;
