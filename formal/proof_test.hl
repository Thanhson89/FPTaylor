needs "build_tform2.hl";;

open List;;
open List_eval;;
open Interval_arith;;
open Arith_float;;
open More_float;;
open Lib;;
open Tform;;
open Build_tform;;
open Bin_float;;
open Eval_expr;;
open Proof;;
open Misc_functions;;
open Misc_vars;;
open Build_tform2;;

let path = "../benchmarks/proofs/proofs";;

let load name =
  let fname = Filename.concat path name in
    load_proof fname;;

let p1 = load "r1.proof";;
let p2 = load "r2.proof";;
let p3 = load "r3.proof";;
let p4 = load "r4.proof";;

let p5 = load "i1.proof";;
let p6 = load "i2.proof";;

(************************)

let pp = 15;;

install_user_printer ("hidden", print_hidden);;
delete_user_printer "hidden";;

(**************)

validate_proof pp p1;;
validate_proof pp p2;;
validate_proof pp p3;;
validate_proof pp p4;;
validate_proof pp p5;;
validate_proof pp p6;;

let proof_sum = load "sum.proof";;
let proof_nonlin1 = load "nonlin1.proof";;
let proof_nonlin2 = load "nonlin2.proof";;

validate_proof pp proof_sum;;
validate_proof pp proof_nonlin1;;
validate_proof pp proof_nonlin2;;

let proof = load "rigidBody1.proof";;
validate_proof pp proof;;

let proof = load "rigidBody2.proof";;
validate_proof pp proof;;

let proof = load "predatorPrey.proof";;
validate_proof pp proof;;

let proof = load "verhulst.proof";;
validate_proof pp proof;;

let proof = load "carbon_gas.proof";;
validate_proof pp proof;;

let proof = load "sine.proof";;
validate_proof pp proof;;

let proof = load "sineOrder3.proof";;
validate_proof pp proof;;

let proof = load "sqroot.proof";;
validate_proof pp proof;;

let proof = load "doppler1.proof";; (* Mul: 47 *)
validate_proof pp proof;;

let proof = load "doppler2.proof";; (* Mul: 47 (div 0) *)
validate_proof pp proof;;

let proof = load "doppler3.proof";; (* Mul: 47 *)
validate_proof pp proof;;

let proof = load "turbine1.proof";;
validate_proof pp proof;;

let proof = load "turbine2.proof";;
validate_proof pp proof;;

let proof = load "turbine3.proof";;
validate_proof pp proof;;

let proof = load "jet.proof";;
validate_proof pp proof;;


(*******************)

let x_tm, dom_tm, dom_vars, var_names = build_domain pp proof.proof_vars;;
let tf = snd (hd (build_tform pp proof));;
let result = prove_bound pp proof tf;;
CONV_RULE bin_float_rat_conv result;;

let proof = p2;;

let tms, ths = 
  try
    [], build_tform pp proof
  with Error(msg, tms, ths) ->
    let _ = print_endline msg in
      tms, enumerate ths;;


(*************)

let approx_th = snd (hd ths);;
let rnd_th = rnd32;;

let [m2_tm; b_tm; i1; i2] = tms;;
let i = dest_small_numeral i_tm and
    j = dest_small_numeral j_tm;;
		      
let err_indices = [dest_small_numeral i1; dest_small_numeral i2];;
let form1 = build_rnd_tform rnd_th m2_tm b_tm err_indices approx_th;;
let form2 = build_rnd_tform_univ rnd_th m2_tm b_tm err_indices approx_th;;

(************)

let th0 = snd (hd ths);;
let arg_ths = map snd (tl ths);;
let hs_forall, hs = partition is_forall (hyp th0);;
let hs_rat, hs_other = partition (fun tm -> frees tm = []) hs;;

let rat_ths = map (EQT_ELIM o (NUM_REDUCE_CONV THENC bin_float_rat_conv)) hs_rat;;
let forall_ths = map (prove_forall_hyp pp dom_vars arg_ths) hs_forall;;

let h_tm = hd hs_forall;;
let approx1_th = nth arg_ths 0 and
    approx2_th = nth arg_ths 1;;

let bound1 = eval_tform1_bound pp approx1_th dom_vars;;
let bound2 = eval_tform1_bound pp approx2_th dom_vars;;
let in_hyp = find (is_binary "IN") (hyp bound1);;
let x_tm = lhand in_hyp;;
let t1 = GEN x_tm (DISCH in_hyp bound1);;
let t2 = GEN x_tm (DISCH in_hyp bound2);;
let th2 = MATCH_MP (MATCH_MP lemma2 t1) t2;;
let b_tm = rand (rand (snd (dest_forall h_tm)));;
let r1 = fst (dest_imp (concl (INST[b_tm, b_var_real] th2)));;

r1;;
eval_form_expr pp (lhand r1) [] [];;
eval_form_expr pp (rand r1) [] [];;

eval_form_expr pp r1 [] [];;

let r2 = EQT_ELIM ((DEPTH_CONV FLOAT_TO_NUM_CONV THENC bin_float_rat_conv) r1);;
  let th3 = MATCH_MP th2 r2 in
    if h_tm <> concl th3 then
      error "prove_bound2" [h_tm] [th3]
    else
      th3;;

(*************)

let approx_th = approx1_th;;

let i = find_max_ipow2 (concl approx_th);;
let th1 = MATCH_MP tform_f1_bound approx_th;;
let th2 = (UNDISCH_ALL o SPEC_ALL) th1;;
let sum_tm = rand (concl th2);;
let eq1_th =
  let conv1 = PURE_REWRITE_CONV[list_mk; sum_list_cons; sum_list_nil; REAL_ADD_RID] in
    if i =/ Int 0 then
      (conv1 THENC PURE_ONCE_REWRITE_CONV[lemma_ipow2_0_mul]) sum_tm
    else
      let conv2 = PURE_ONCE_REWRITE_CONV[SPEC (mk_intconst i) lemma_ipow2_mul] in
      let conv3 = PURE_REWRITE_CONV[REAL_ADD_RDISTRIB; GSYM REAL_MUL_ASSOC; GSYM ipow2_add] in
      let conv4 = PURE_REWRITE_CONV[ipow2_0; REAL_MUL_LID; REAL_MUL_RID; 
				    REAL_ADD_RID; REAL_ADD_LID] in
	(conv1 THENC conv2 THENC conv3 THENC INT_REDUCE_CONV THENC conv4) sum_tm;;
let expr_tm1 = rand (rand (concl eq1_th));;
(*  let conv5 = bin_float_rat_conv in *)
let conv5 = REWRITE_CONV[];;
let eq2_th = conv5 expr_tm1;;
let eq_th = GEN_REWRITE_RULE (RAND_CONV o RAND_CONV) [eq2_th] eq1_th;;
let expr_tm2 = rand (concl eq2_th);;
let expr_interval = eval_form_expr pp expr_tm2 dom_vars [];;
(*
  let ifun = build_interval_fun expr_tm2 in
  let expr_interval = eval_interval_fun pp ifun dom_vars [] in
*)
let r2 = PURE_REWRITE_RULE[eq_th] th2;;
let t1 = CONJ expr_interval r2;;

    MATCH_MP lemma_trans t1;;

(**********************)

