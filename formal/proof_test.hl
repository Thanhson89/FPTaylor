needs "build_tform2.hl";;

open List;;
open List_eval;;
open Interval_arith;;
open Arith_float;;
open More_float;;
open Lib;;
open Tform;;
open Build_tform;;
open Ipow;;
open Bin_float;;
open Eval_expr;;
open Proof;;
open Misc_functions;;
open Misc_vars;;
open Build_tform2;;

let trans_bound bound_th bound_tm =
  let vars, tm = strip_forall (concl bound_th) in
  let ineq_th = UNDISCH_ALL (SPEC_ALL bound_th) in
  let cond, ineq = dest_imp tm in
  let bound0_tm = rand ineq in
  let ineq2 = mk_binary "real_le" (bound0_tm, bound_tm) in
  let ineq2_th = EQT_ELIM ((REWRITE_CONV[IPOW_NEG; IPOW_NUM] THENC bin_float_rat_conv) ineq2) in
  let trans_th = MATCH_MP REAL_LE_TRANS (CONJ ineq_th ineq2_th) in
  let r1 = DISCH cond trans_th in
    itlist GEN vars r1;;

let path = "../benchmarks/proofs/proofs";;

let load name =
  let fname = Filename.concat path name in
    load_proof fname;;

let validate pp name =
  let proof = load name in
  let start = Unix.gettimeofday() in
  let form_th, bound_th = validate_proof pp proof in
  let stop = Unix.gettimeofday() in
    form_th, bound_th, stop -. start;;

let t1 = load "t1.proof";;
let t2 = load "t2.proof";;
let t3 = load "t3.proof";;

let p1 = load "r1.proof";;
let p2 = load "r2.proof";;
let p3 = load "r3.proof";;
let p4 = load "r4.proof";;

let p5 = load "i1.proof";;
let p6 = load "i2.proof";;

(************************)

let pp = 10;;

install_user_printer ("hidden", print_hidden);;
delete_user_printer "hidden";;



(**************)

let proof = load "i3.proof";;
validate_proof pp proof;;

let proof = load "i4.proof";;
validate_proof pp proof;;

let proof = load "i5.proof";;
validate_proof pp proof;;

let proof = load "i6.proof";;
validate_proof pp proof;;

validate_proof pp t1;;
validate_proof pp t2;;
validate_proof pp t3;;

validate_proof pp p1;;
validate_proof pp p2;;
validate_proof pp p3;;
validate_proof pp p4;;
validate_proof pp p5;;
validate_proof pp p6;;

let proof_sum = load "sum.proof";;
let proof_nonlin1 = load "nonlin1.proof";;
let proof_nonlin2 = load "nonlin2.proof";;

validate_proof pp proof_sum;;
validate_proof pp proof_nonlin1;;
validate_proof pp proof_nonlin2;;

let proof = load "carbon_gas.proof";;
let form_th, bound_th = validate_proof 15 proof;;
trans_bound bound_th `#1.241 * &10 ipow (-- &8)`;;

let proof = load "verhulst.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#3.491 * &10 ipow (-- &16)`;;

let proof = load "predatorPrey.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#1.865 * &10 ipow (-- &16)`;;

let proof = load "rigidBody1.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#3.865 * &10 ipow (-- &13)`;;

let proof = load "rigidBody2.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#5.233 * &10 ipow (-- &11)`;;

let proof = load "doppler1.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#1.569 * &10 ipow (-- &13)`;;

let proof = load "doppler2.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#2.870 * &10 ipow (-- &13)`;;

let proof = load "doppler3.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#8.150 * &10 ipow (-- &14)`;;

let proof = load "sine.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#6.701 * &10 ipow (-- &16)`;;

let proof = load "sqroot.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#7.863 * &10 ipow (-- &16)`;;

let proof = load "sineOrder3.proof";;
let form_th, bound_th = validate_proof 15 proof;;
trans_bound bound_th `#9.960 * &10 ipow (-- &16)`;;

let proof = load "turbine1.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#2.494 * &10 ipow (-- &14)`;;

let proof = load "turbine2.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#3.337 * &10 ipow (-- &14)`;;

let proof = load "turbine3.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#1.794 * &10 ipow (-- &14)`;;

let proof = load "jet.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#1.484 * &10 ipow (-- &11)`;;

(* -------------- *)
(* Trans          *)
(* -------------- *)

let proof = load "logexp.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#1.710 * &10 ipow (-- &15)`;;

let proof = load "sphere.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound bound_th `#1.288 * &10 ipow (-- &14)`;;

let proof = load "azimuth.proof";;
let form_th, bound_th = validate_proof pp proof;;
trans_bound result `#1.409 * &10 ipow (-- &14)`;;

(* 100: 9.001 *)
validate pp "logexp.proof";;

(* 100: 28.767 *)
validate pp "sphere.proof";;


(*******************)

trans_bound bound_th `&10 ipow (-- &1)`;;    
;;
REAL_LE_TRANS;;


let pp = 10;;
let proof = load "v1.proof";;

let x_tm, dom_tm, dom_vars, var_names = build_domain pp proof.proof_vars;;
let tf = snd (hd (build_tform pp proof));;
let result = prove_bound pp proof tf;;
CONV_RULE bin_float_rat_conv result;;

let proof = p1;;

let tms, ths = 
  try
    [], build_tform pp proof
  with Error(msg, tms, ths) ->
    let _ = print_endline msg in
      tms, enumerate ths;;


(*************)

let approx_th = snd (hd ths);;
let rnd_th = rnd32;;

let [m2_tm; b_tm; i1; i2] = tms;;
let i = dest_small_numeral i_tm and
    j = dest_small_numeral j_tm;;
		      
let err_indices = [dest_small_numeral i1; dest_small_numeral i2];;
let form1 = build_rnd_tform rnd_th m2_tm b_tm err_indices approx_th;;
let form2 = build_rnd_tform_univ rnd_th m2_tm b_tm err_indices approx_th;;

(************)

let rnd_th = snd (nth ths 0);;
let n_tm = nth tms 0 and
    b_tm = nth tms 1;;

let index = rev_assoc "x" var_names;;
let err_indices = [1];;

let th0 = build_rnd_bin_var_tform dom_tm index rnd_th n_tm b_tm err_indices;;

let th0 = approx_th;;
let hs_forall, hs = partition is_forall (hyp th0);;
let hs_rat, hs_other = partition (fun tm -> frees tm = []) hs;;
let rat_ths = map prove_rat_hyp hs_rat;;

let h_tm = hd hs_forall;;
prove_forall_hyp pp var_names dom_vars [] h_tm;;


(*************)

let h_tm = hd tms;;
let approx_th = snd (nth ths 1);;

h_tm;;
approx_th;;
REWRITE_RULE[] approx_th;;

let bound = eval_tform1_bound pp approx_th dom_vars;;
let in_hyp = find (is_binary "IN") (hyp bound);;
let x_tm = lhand in_hyp;;
let t = GEN x_tm (DISCH in_hyp bound);;
let th2 = MATCH_MP lemma3 t;;
let tm1, tm2 = dest_conj (rand (snd (dest_forall h_tm)));;
let m1_tm = rand tm1 and
    b_tm = rand tm2;;
let r1 = fst (dest_imp (concl (SPECL[m1_tm; b_tm] th2)));;
let r2 = EQT_ELIM ((DEPTH_CONV FLOAT_TO_NUM_CONV THENC bin_float_rat_conv) r1);;
let th3 = MATCH_MP th2 r2;;

h_tm;;
let a, b = dest_conj h_tm;;
concl th3;;

if h_tm <> concl th3 then false else true;;
      error "prove_bound3" [h_tm] [th3; approx_th]
    else
      th3;;
