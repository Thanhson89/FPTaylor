(* ========================================================================== *)
(* FLOATING POINT THEOREMS                                                    *)
(* ========================================================================== *)

needs "float.hl";;

(* -------------------------------------------------------------------------- *)
(* Lemma. All fformats are valid.                                             *)
(* -------------------------------------------------------------------------- *)

let FFORMAT_SPLIT = TAUT `!(fmt:fformat). 
  (dest_fformat fmt) = (FST (dest_fformat fmt), SND (dest_fformat fmt))`;;

let FFORMAT_VALID = prove(`!(fmt:fformat). is_valid_format (dest_fformat fmt)`,
			  REWRITE_TAC[fformat_typbij]);;

let FFORMAT_RADIX_LT_1 =
  prove(`!(fmt:fformat). 1 < (fradix fmt)`,
	GEN_TAC THEN REWRITE_TAC[fradix] THEN 
	  ASSUME_TAC (REWRITE_RULE [is_valid_format] 
			(ONCE_REWRITE_RULE [FFORMAT_SPLIT] FFORMAT_VALID)) THEN
	  ASM_REWRITE_TAC[]);;

(* -------------------------------------------------------------------------- *)
(* Useful properties of ipow                                                  *)
(* -------------------------------------------------------------------------- *)

(* Lemma. Every non-negative integer has a natural number analog.             *)
let INT_TO_NUM = 
  prove(`!(x:int). &0 <= x ==> ?(n:num). num_of_int(x) = n`,
	GEN_TAC THEN DISCH_THEN(fun thm -> 
        ONCE_REWRITE_TAC[REWRITE_RULE [GSYM NUM_OF_INT] thm]) THEN
	EXISTS_TAC `(num_of_int x)` THEN REWRITE_TAC[NUM_OF_INT_OF_NUM]);;

let IPOW_FROM_POW =
  prove(`!(P:((real->num->real)->bool)). P(pow) ==> P(ipow)`,
  

(* Lemma. For all x > 0, x^i > 0.                                             *)
let IPOW_POS =
  prove(`!(x:real) (i:int). &0 < x ==> &0 < x ipow i`,
	REPEAT GEN_TAC THEN DISCH_TAC THEN REWRITE_TAC[ipow] THEN
	COND_CASES_TAC THENL [
	  SUBGOAL_THEN `&0 <= --(i:int)` (fun thm -> CHOOSE_TAC (MATCH_MP
                                          INT_TO_NUM thm)) THENL [
	    MATCH_MP_TAC (ARITH_RULE `(i:int) < &0 ==> &0 <= --i`) THEN
            ASM_REWRITE_TAC[];
            ALL_TAC] 
          THEN
	  ASM_REWRITE_TAC[REAL_LT_INV_EQ] THEN MATCH_MP_TAC REAL_POW_LT THEN
          ASM_REWRITE_TAC[];
          ALL_TAC]
          THEN
          CHOOSE_TAC (MATCH_MP INT_TO_NUM (MATCH_MP (ARITH_RULE 
          `~((i:int) < &0) ==> &0 <= i`) (ASSUME `~((i:int) < &0)`))) THEN
       	  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_POW_LT THEN 
          ASM_REWRITE_TAC[]);;

(* Lemma. For all y > 0, there is an n > 0 such that 1 / n < y.               *)
let REAL_ARCH_DIV = 
  prove(`!(y:real). &0 < y ==> ?(n:num). &0 < &n /\ (&1 / &n) < y`,
	GEN_TAC THEN DISCH_THEN(fun thm -> (CHOOSE_TAC (SPEC `&1` 
        (MATCH_MP REAL_ARCH thm)))) THEN EXISTS_TAC `n:num` THEN
	
	SUBGOAL_THEN `&0 < &n` ASSUME_TAC THENL [

	  SUBGOAL_THEN `&0 < &n * y` ASSUME_TAC THENL [ASM_ARITH_TAC; ALL_TAC] 
	  THEN

	  ASSUME_TAC (REWRITE_RULE [REAL_MUL_POS_LT] (ASSUME `&0 < &n * y`))
	  THEN ASM_ARITH_TAC; ALL_TAC] THEN

	ASM_REWRITE_TAC[] THEN REWRITE_TAC[UNDISCH(SPECL 
	[`&1 / &n`; `y:real`; `(&n):real`] (GSYM REAL_LT_LMUL_EQ))] THEN
	REWRITE_TAC[real_div] THEN GEN_REWRITE_TAC (RATOR_CONV o
        RAND_CONV o RAND_CONV o ONCE_DEPTH_CONV) [REAL_MUL_LID] THEN
	
	SUBGOAL_THEN `~(&n = &0)` (fun thm -> REWRITE_TAC[MATCH_MP 
        REAL_MUL_RINV thm]) THENL [ASM_ARITH_TAC; ALL_TAC] THEN

	ASM_REWRITE_TAC[]);;

(* Lemma. For all x > 1, y > 0, there is an i such that x^i < y.              *)
let IPOW_LT =
  prove(`!(x:real) (y:real). ?(i:int). x ipow i < y`,
	
			    

(* -------------------------------------------------------------------------- *)
(* Lemma. For any integer i and valid radix r, r^i > 0.                       *)
(* -------------------------------------------------------------------------- *)

let RADIX_IPOW_POS =
  prove(`!(fmt:fformat) (i:int). &0 < &(fradix fmt) ipow i`,
	REPEAT GEN_TAC THEN MATCH_MP_TAC IPOW_POS THEN
        MATCH_MP_TAC (ARITH_RULE `&1 < x ==> &0 < x`) THEN
        REWRITE_TAC[REAL_OF_NUM_LT] THEN REWRITE_TAC[FFORMAT_RADIX_LT_1]);;

(* -------------------------------------------------------------------------- *)
(* Lemma. If x is a non-zero fp number, then its fraction is non-zero.        *)
(* -------------------------------------------------------------------------- *)

let NONZERO_FRAC =
  prove(`!(fmt:fformat) (x:real) (f:num) (e:int).
	  ~(x = &0) /\ (frep(fmt) f e x) ==> 0 < f`,
	REPEAT GEN_TAC THEN REWRITE_TAC[frep] THEN STRIP_TAC THEN
	
	SUBGOAL_THEN `&0 < abs(x)` ASSUME_TAC THENL [
	  ASM_ARITH_TAC; ALL_TAC] THEN 

	SUBGOAL_THEN `&f * &(fradix fmt) ipow (e - &(fprec fmt) + &1) = abs(x)`
	ASSUME_TAC THENL [
	  ASM_REWRITE_TAC[]; ALL_TAC] THEN

	SUBGOAL_THEN `&0 < &f * &(fradix fmt) ipow (e - &(fprec fmt) + &1)`
        ASSUME_TAC THENL [
	  ONCE_ASM_REWRITE_TAC[] THEN ASM_REWRITE_TAC[]; ALL_TAC] THEN

	ASSUME_TAC (REWRITE_RULE [REAL_MUL_POS_LT]
        (ASSUME `&0 < &f * &(fradix fmt) ipow (e - &(fprec fmt) + &1)`)) THEN
	  
	ASSUME_TAC (SPECL [`fmt:fformat`; `(e - &(fprec fmt) + &1):int`]
	RADIX_IPOW_POS) THEN

	REWRITE_TAC[GSYM(REAL_OF_NUM_LT)] ASM_ARITH_TAC);;

(* -------------------------------------------------------------------------- *)
(* Theorem. If x is a non-zero fp number, then there exists a unique          *)
(* normalized fraction and exponent for x.                                    *)
(* -------------------------------------------------------------------------- *)

let NORMALIZED_FRAC_EXISTS =
  prove(`!(fmt:fformat) (x:real) (f:num) (e:int). 
	  ~(x = &0) /\ (frep(fmt) f e x) ==> (is_norm_frac(fmt) f x)`,
	
