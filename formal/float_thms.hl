(* ========================================================================== *)
(* FLOATING POINT THEOREMS                                                    *)
(* ========================================================================== *)

(* needs "common.hl";; *)
(* needs "fixed_thms.hl";; *)
(* needs "fixed.hl";; *)
(* needs "float.hl";; *)

(* -------------------------------------------------------------------------- *)
(* Valid flformat properties                                                  *)
(* -------------------------------------------------------------------------- *)

let FLFORMAT_SPLIT = TAUT `!(fmt:flformat).
  (dest_flformat fmt) = (FST (dest_flformat fmt),
			 SND (dest_flformat fmt))`;;

let FLFORMAT_VALID_IMP_RADIX_LT_1 =
  prove(`!(r:num) (p:num). ((is_valid_flformat (r,p)) ==> 
				      1 < (FST (r,p)))`,
	REPEAT GEN_TAC THEN REWRITE_TAC[is_valid_flformat] THEN ARITH_TAC);;

let FLFORMAT_VALID_IMP_RADIX_EVEN =
  prove(`!(r:num) (p:num). ((is_valid_flformat (r,p)) ==> 
				      EVEN (FST (r,p)))`,
	REPEAT GEN_TAC THEN REWRITE_TAC[is_valid_flformat] THEN MESON_TAC[]);;

let FLFORMAT_VALID_IMP_PREC_LT_0 =
  prove(`!(r:num) (p:num). ((is_valid_flformat (r,p)) ==> 
				      0 < (SND (r,p)))`,
	REPEAT GEN_TAC THEN REWRITE_TAC[is_valid_flformat] THEN MESON_TAC[]);;

let FLFORMAT_VALID = 
  prove(`!(fmt:flformat). is_valid_flformat (dest_flformat fmt)`,
	REWRITE_TAC[flformat_typbij]);;

let FLFORMAT_RADIX_LT_1 =
  prove(`!(fmt:flformat). 1 < (flr fmt)`,
	GEN_TAC THEN REWRITE_TAC[flr] THEN ONCE_REWRITE_TAC[FLFORMAT_SPLIT] THEN
	  MATCH_MP_TAC FLFORMAT_VALID_IMP_RADIX_LT_1 THEN
	  REWRITE_TAC[FLFORMAT_VALID]);;

let FLFORMAT_RADIX_LT_0 =
  prove(`!(fmt:flformat). 0 < (flr fmt)`,
	GEN_TAC THEN MATCH_MP_TAC (ARITH_RULE `1 < x ==> 0 < x`) THEN
        REWRITE_TAC[FLFORMAT_RADIX_LT_1]);;

let FLFORMAT_RADIX_NE_0 =
  prove(`!(fmt:flformat). ~(&(flr fmt) = &0)`,
	GEN_TAC THEN REWRITE_TAC[REAL_OF_NUM_EQ] THEN MATCH_MP_TAC 
        (ARITH_RULE `0 < x ==> ~(x = 0)`) THEN
        REWRITE_TAC[FLFORMAT_RADIX_LT_0]);;

let FLFORMAT_RADIX_EVEN =
  prove(`!(fmt:flformat). EVEN (flr fmt)`,
	GEN_TAC THEN REWRITE_TAC[flr] THEN ONCE_REWRITE_TAC[FLFORMAT_SPLIT] THEN
	  MATCH_MP_TAC FLFORMAT_VALID_IMP_RADIX_EVEN THEN
	  REWRITE_TAC[FLFORMAT_VALID]);;

let FLFORMAT_RADIX_LE_2 =
  prove(`!(fmt:flformat). 2 <= (flr fmt)`,
	GEN_TAC THEN 
        SUBGOAL_THEN `!x. ~(x = 0) /\ EVEN x ==> 2 <= x` MATCH_MP_TAC THENL [
	  GEN_TAC THEN
	  DISCH_THEN (LABEL_CONJUNCTS_TAC ["xneq0"; "evenx"]) THEN
          ASM_CASES_TAC `x = 0` THENL [
	    ASM_ARITH_TAC; ALL_TAC] THEN
	  ASM_CASES_TAC `x = 1` THENL [
	    USE_THEN "evenx" (fun evenx -> 
            ASSUME_TAC (REWRITE_RULE[ASSUME `x = 1`] evenx)) THEN
            ASSUME_TAC (REWRITE_RULE[GSYM NOT_EVEN] (ARITH_RULE `ODD 1`)) THEN
            ASM_ARITH_TAC; ASM_ARITH_TAC]; ALL_TAC] THEN
        REWRITE_TAC[REWRITE_RULE[REAL_OF_NUM_EQ] FLFORMAT_RADIX_NE_0] THEN 
        REWRITE_TAC[FLFORMAT_RADIX_EVEN]);;

let FLFORMAT_PREC_LT_0 =
  prove(`!(fmt:flformat). 0 < (flp fmt)`,
	GEN_TAC THEN REWRITE_TAC[flp] THEN ONCE_REWRITE_TAC[FLFORMAT_SPLIT] THEN
	  MATCH_MP_TAC FLFORMAT_VALID_IMP_PREC_LT_0 THEN
	  REWRITE_TAC[FLFORMAT_VALID]);;

let FLFORMAT_PREC_MINUS_1 =
  prove(`!(fmt:flformat). &0 <= (&(flp fmt):int) - (&1:int)`,
        REWRITE_TAC[ARITH_RULE `&0 <= x:int - &1:int <=> &1 <= x`] THEN
        REWRITE_TAC[INT_OF_NUM_LE] THEN
        REWRITE_TAC[ARITH_RULE `1 <= n <=> 0 < n`] THEN
	REWRITE_TAC[FLFORMAT_PREC_LT_0]);;

let FLFORMAT_PREC_IPOW_EQ_EXP =
  prove(`!(fmt:flformat). &(flr fmt) ipow (&(flp fmt) - &1) = 
      &((flr fmt) EXP ((flp fmt) - 1))`,
	REPEAT GEN_TAC THEN MATCH_MP_TAC IPOW_EQ_EXP_P THEN
	REWRITE_TAC[FLFORMAT_PREC_LT_0]);;

let FLFORMAT_RADIX_IPOW_LE_0 =
  prove(`!(fmt:flformat) (e:int). &0 <= &(flr fmt) ipow e`,
	REPEAT GEN_TAC THEN
	MATCH_MP_TAC (ARITH_RULE `&0 < (x:real) ==> &0 <= x`) THEN
	MATCH_MP_TAC IPOW_LT_0 THEN
	REWRITE_TAC[REAL_OF_NUM_LT] THEN
	REWRITE_TAC[FLFORMAT_RADIX_LT_0]);;

let FLFORMAT_RADIX_IPOW_LT_0 =
  prove(`!(fmt:flformat) (e:int). &0 < &(flr fmt) ipow e`,
	REPEAT GEN_TAC THEN
	MATCH_MP_TAC IPOW_LT_0 THEN
	REWRITE_TAC[REAL_OF_NUM_LT] THEN
	REWRITE_TAC[FLFORMAT_RADIX_LT_0]);;

let FLFORMAT_RADIX_IPOW_NEQ_0 =
  prove(`!(fmt:flformat) (e:int). ~(&(flr fmt) ipow e = &0)`,
	REPEAT GEN_TAC THEN 
        MATCH_MP_TAC (ARITH_RULE `&0 < (x:real) ==> ~(x = &0)`) THEN
	MATCH_MP_TAC IPOW_LT_0 THEN
	REWRITE_TAC[REAL_OF_NUM_LT] THEN
        REWRITE_TAC[FLFORMAT_RADIX_LT_0]);;

let FLFORMAT_RADIX_IPOW_ADD_EXP =
  prove(`!(fmt:flformat) (u:int) (v:int). 
	&(flr fmt) ipow u * &(flr fmt) ipow v = &(flr fmt) ipow (u + v)`, 
	REPEAT GEN_TAC THEN MATCH_MP_TAC IPOW_ADD_EXP THEN
	REWRITE_TAC[FLFORMAT_RADIX_NE_0]);;

let FLFORMAT_TO_FFORMAT =
  prove(`!(fmt:flformat) (e:int). ?(fmt':fformat). 
	  (to_fformat fmt e) = fmt' /\ 
          (fr fmt') = (flr fmt)     /\ 
          (fp fmt') = (flp fmt)     /\
          (fe fmt') = e`,
	REPEAT GEN_TAC THEN 
        EXISTS_TAC `mk_fformat ((flr fmt), (flp fmt), e)` THEN
        REWRITE_TAC[to_fformat] THEN REWRITE_TAC[fr;fp;fe] THEN
        SUBGOAL_THEN `is_valid_fformat ((flr fmt), (flp fmt), e)`
           (LABEL_TAC "valid") THENL [
	     REWRITE_TAC[is_valid_fformat] THEN 
             REWRITE_TAC[FLFORMAT_RADIX_LT_1] THEN
             REWRITE_TAC[FLFORMAT_RADIX_EVEN] THEN
             REWRITE_TAC[FLFORMAT_PREC_LT_0]; ALL_TAC] THEN
        USE_THEN "valid" (fun valid ->
        REWRITE_TAC[REWRITE_RULE[fformat_typbij] valid]));;

(* -------------------------------------------------------------------------- *)
(* Useful ipow/exp properties, translated over to floating point              *)
(* -------------------------------------------------------------------------- *)

let FLOAT_IPOW_LE_REAL =
  prove(`!(fmt:flformat) (z:real). ?(e:int). z <= &(flr fmt) ipow e`,
	GEN_TAC THEN 
        REWRITE_TAC[MATCH_MP IPOW_LE_REAL 
                             (SPEC `fmt:flformat`FLFORMAT_RADIX_LE_2)]);;

let FLOAT_IPOW_LE_REAL_2 =
  prove(`!(fmt:flformat) (z:real). &0 < z ==> ?(e:int). &(flr fmt) ipow e <= z`,
	REPEAT GEN_TAC THEN DISCH_THEN (fun thm ->
        REWRITE_TAC[MATCH_MP IPOW_LE_REAL_2 (CONJ thm
        (SPEC `fmt:flformat`FLFORMAT_RADIX_LE_2))]));;

(* -------------------------------------------------------------------------- *)
(* greatest_e, greatest_m, greatest_r                                         *)
(* -------------------------------------------------------------------------- *)

let is_greatest_e = define
  `is_greatest_e (fmt:flformat) (x:real) (e:int) =
  (&(flr fmt) ipow e <= abs(x) /\ !(e':int). &(flr fmt) ipow e' <= abs(x)
     ==> e' <= e)`;;

let FLOAT_GREATEST_E_EXISTS =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
           ?(e:int). greatest_e(fmt) x = e /\ is_greatest_e(fmt) x e`,
	REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
	SUBGOAL_THEN `~({ e:int | &(flr fmt) ipow e <= abs(x) } = {})`
           (LABEL_TAC "neqempty") THENL [
	  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
          REWRITE_TAC[IN_ELIM_THM] THEN
          USE_THEN "xneq0" (fun xneq0 ->
          REWRITE_TAC[MATCH_MP FLOAT_IPOW_LE_REAL_2
          (MATCH_MP
             (ARITH_RULE `~((x:real) = &0) ==> &0 < abs(x)`) xneq0)]);
          ALL_TAC] THEN
	SUBGOAL_THEN `?(b:int). !(e:int). e IN
              { e:int | &(flr fmt) ipow e <= abs(x) } ==> e <= b`
           (CHOOSE_THEN (LABEL_TAC "bound")) THENL [
	  CHOOSE_TAC (SPECL [`fmt:flformat`; `abs((x:real))`]
                       FLOAT_IPOW_LE_REAL) THEN
          EXISTS_TAC `e:int` THEN
          GEN_TAC THEN REWRITE_TAC[IN_ELIM_THM] THEN
          DISCH_TAC THEN MATCH_MP_TAC IPOW_MONOTONE THEN
          EXISTS_TAC `(flr fmt)` THEN REWRITE_TAC[FLFORMAT_RADIX_LE_2] THEN
          ASM_ARITH_TAC; ALL_TAC] THEN
        USE_THEN "neqempty" (fun neqempty -> USE_THEN "bound" (fun bound ->
	CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["supint"; "issupint"])
        (MATCH_MP SUP_INT_BOUNDED (CONJ neqempty bound)))) THEN
        EXISTS_TAC `e':int` THEN REWRITE_TAC[greatest_e; is_greatest_e] THEN
        ASM_REWRITE_TAC[] THEN USE_THEN "issupint" (fun issupint ->
        (LABEL_CONJUNCTS_TAC ["inset"; "biggest"]) (REWRITE_RULE[is_sup_int]
        issupint)) THEN
        CONJ_TAC THENL [
	  USE_THEN "inset" (fun inset -> REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM]
          inset]);
	  USE_THEN "biggest" (fun biggest -> 
          REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] biggest])]);;

let is_greatest_m = define
  `is_greatest_m (fmt:flformat) (x:real) (m:num) =
  (&m * &(flr fmt) ipow (greatest_e(fmt) x) <= abs(x) /\
  !(m':num). &m' * &(flr fmt) ipow (greatest_e(fmt) x) <= abs(x) ==>
   m' <= m)`;;

let FLOAT_GREATEST_M_EXISTS =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
           ?(m:num). greatest_m(fmt) x = m /\ 
                     is_greatest_m(fmt) x m /\
                     1 <= m /\
                     m < (flr fmt)`,
	REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
	SUBGOAL_THEN `1 IN { (m:num) | 
              &m * &(flr fmt) ipow (greatest_e(fmt) x) <= abs(x) }`
        (LABEL_TAC "oneins") THENL [
	  REWRITE_TAC[IN_ELIM_THM] THEN
	  REWRITE_TAC[ARITH_RULE `&1 * (x:real) = x`] THEN
          USE_THEN "xneq0" (fun xneq0 -> CHOOSE_THEN
          (LABEL_CONJUNCTS_TAC ["geeq"; "isge"]) 
          (SPEC `fmt:flformat` (MATCH_MP FLOAT_GREATEST_E_EXISTS xneq0))) THEN
	  ASM_REWRITE_TAC[] THEN USE_THEN "isge" (fun isge ->
          REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[is_greatest_e]
          isge)]); ALL_TAC] THEN
	SUBGOAL_THEN `~({ (m:num) | &m * &(flr fmt) ipow (greatest_e(fmt) x) <=
                      abs(x) } = {})`
           (LABEL_TAC "neqempty") THENL [
	  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
          EXISTS_TAC `1:num` THEN ASM_REWRITE_TAC[]; ALL_TAC] THEN
	SUBGOAL_THEN `!(m:num). m IN
              { (m:num) | &m * &(flr fmt) ipow (greatest_e(fmt) x) <=
                      abs(x) } ==> m < (flr fmt)` 
           (LABEL_TAC "bound") THENL [
          GEN_TAC THEN REWRITE_TAC[IN_ELIM_THM] THEN
          USE_THEN "xneq0" (fun xneq0 -> CHOOSE_THEN
          (LABEL_CONJUNCTS_TAC ["geeq"; "isge"]) 
          (SPEC `fmt:flformat` (MATCH_MP FLOAT_GREATEST_E_EXISTS xneq0))) THEN
          ASM_REWRITE_TAC[] THEN
          ASM_CASES_TAC `m < (flr fmt)` THENL [
	    ASM_ARITH_TAC;
	    SUBGOAL_THEN `?k. m = (flr fmt) + k` CHOOSE_TAC THENL [
	      EXISTS_TAC `m - (flr fmt)` THEN
              ASM_ARITH_TAC; ALL_TAC] THEN
            ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
            SUBGOAL_THEN `&(flr fmt) ipow (e + &1) <= abs(x)`
            (LABEL_TAC "eplus1") THENL [
	      REWRITE_TAC[GSYM(MATCH_MP IPOW_ADD_EXP 
                           (SPEC `fmt:flformat`FLFORMAT_RADIX_NE_0))] THEN
              REWRITE_TAC[IPOW_TO_1] THEN
              ONCE_REWRITE_TAC[ARITH_RULE `(a:real) * b = b * a`] THEN
              ASSUME_TAC (REWRITE_RULE[ARITH_RULE `((a:real) + b) * c =
              a * c + b * c`] (REWRITE_RULE[GSYM REAL_OF_NUM_ADD]
              (ASSUME `&(flr fmt + k) * &(flr fmt) ipow e <= abs x`))) THEN
              MATCH_MP_TAC (ARITH_RULE 
                `!z. &0 <= z /\ (a:real) + z <= b ==> a <= b`) THEN
              EXISTS_TAC `&k * &(flr fmt) ipow e` THEN ASM_REWRITE_TAC[] THEN
              MATCH_MP_TAC REAL_LE_MUL THEN 
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0] THEN ARITH_TAC; 
              ALL_TAC] THEN
            USE_THEN "eplus1" (fun eplus1 -> USE_THEN "isge" (fun isge ->
            LABEL_TAC "eplus1leqe" (MATCH_MP (CONJUNCT2 (
            REWRITE_RULE[is_greatest_e] isge)) eplus1))) THEN
            ASM_ARITH_TAC]; ALL_TAC] THEN
	SUBGOAL_THEN `!(m:num). m IN
              { (m:num) | &m * &(flr fmt) ipow (greatest_e(fmt) x) <=
                      abs(x) } ==> m <= (flr fmt)` 
           (LABEL_TAC "bound2") THENL [
             GEN_TAC THEN
	     DISCH_THEN (fun thm -> USE_THEN "bound" (fun bound ->
             ASSUME_TAC (MATCH_MP bound thm))) THEN ASM_ARITH_TAC; ALL_TAC] THEN
        USE_THEN "neqempty" (fun neqempty -> USE_THEN "bound2" (fun bound2 ->
	CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["supnum"; "issupnum"])
        (MATCH_MP SUP_NUM_BOUNDED (CONJ neqempty bound2)))) THEN
        EXISTS_TAC `n':num` THEN REWRITE_TAC[greatest_m; is_greatest_m] THEN
        ASM_REWRITE_TAC[] THEN USE_THEN "issupnum" (fun issupnum ->
        (LABEL_CONJUNCTS_TAC ["inset"; "biggest"]) (REWRITE_RULE[is_sup_num]
        issupnum)) THEN
        CONJ_TAC THENL [
	  CONJ_TAC THENL [
	    USE_THEN "inset" (fun inset -> REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM]
            inset]);
	    USE_THEN "biggest" (fun biggest -> 
            REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] biggest])];
	  CONJ_TAC THENL [
	    USE_THEN "oneins" (fun oneins -> USE_THEN "biggest" (fun biggest ->
            REWRITE_TAC[MATCH_MP biggest oneins]));
            USE_THEN "bound" (fun bound -> USE_THEN "inset" (fun inset -> 
            REWRITE_TAC[MATCH_MP bound inset]))]]);;

let dump_ge_gm_info xneq0 =
  USE_THEN "xneq0" (fun xneq0 -> CHOOSE_THEN
  (LABEL_CONJUNCTS_TAC ["geeq"; "isge"]) 
  (SPEC `fmt:flformat` (MATCH_MP FLOAT_GREATEST_E_EXISTS xneq0))) THEN
  REMOVE_THEN "isge" (fun isge -> LABEL_CONJUNCTS_TAC ["geleqx"; "gebig"] 
  (REWRITE_RULE[is_greatest_e] isge)) THEN
  USE_THEN "xneq0" (fun xneq0 -> CHOOSE_THEN
  (LABEL_CONJUNCTS_TAC ["gmeq"; "isgm"; "gmgeq1"; "gmltr"]) 
  (SPEC `fmt:flformat` (MATCH_MP FLOAT_GREATEST_M_EXISTS xneq0))) THEN
  REMOVE_THEN "isgm" (fun isgm -> LABEL_CONJUNCTS_TAC ["gmleqx2"; "gmbig2"] 
  (REWRITE_RULE[is_greatest_m] isgm)) THEN
  REMOVE_THEN "gmleqx2" (fun gmleqx2 -> USE_THEN "geeq" (fun geeq ->
  LABEL_TAC "gmleqx" (REWRITE_RULE[geeq] gmleqx2))) THEN
  REMOVE_THEN "gmbig2" (fun gmbig2 -> USE_THEN "geeq" (fun geeq ->
  LABEL_TAC "gmbig" (REWRITE_RULE[geeq] gmbig2)));;

let dump_flformat_conv expterm =
  CHOOSE_THEN
  (LABEL_CONJUNCTS_TAC ["fmteq"; "fmteqr"; "fmteqp"; "fmteqe"])
  (SPECL [`fmt:flformat`; expterm] FLFORMAT_TO_FFORMAT);;
	    
let FLOAT_GREATEST_R_EXISTS =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
           ?(y:real). greatest_r(fmt) x = y /\ 
                      abs(y) < (finf (to_fformat fmt (greatest_e(fmt) x)))`,
	REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
	USE_THEN "xneq0" (fun xneq0 -> dump_ge_gm_info xneq0) THEN
        ASM_REWRITE_TAC[] THEN dump_flformat_conv `e:int` THEN
        ASM_REWRITE_TAC[] THEN REWRITE_TAC[greatest_r] THEN
        ASM_CASES_TAC `&0 <= (x:real)` THENL [
	  (* 0 <= x *)
	  ASM_REWRITE_TAC[] THEN
          EXISTS_TAC `x - &m * &(flr fmt) ipow e` THEN REWRITE_TAC[] THEN
          SUBGOAL_THEN `abs(x - &m * &(flr fmt) ipow e) =
                            x - &m * &(flr fmt) ipow e`
          (fun thm -> REWRITE_TAC[thm]) THENL [
	    ASM_ARITH_TAC; ALL_TAC] THEN 
          REWRITE_TAC[finf] THEN ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `(x:real) - y < z <=> x < y + z`] THEN
	  USE_THEN "gmbig" (fun gmbig -> LABEL_TAC "mplus1"
          (MATCH_MP (ONCE_REWRITE_RULE[GSYM CONTRAPOS_THM] gmbig)
             (ARITH_RULE `~(m + 1 <= m)`))) THEN
          REWRITE_TAC[ARITH_RULE `(a:real) * b + b = (a + &1) * b`] THEN
          REWRITE_TAC[REAL_OF_NUM_ADD] THEN ASM_ARITH_TAC;

          (* x < 0 *)
	  ASM_REWRITE_TAC[] THEN 
          EXISTS_TAC `x + &m * &(flr fmt) ipow e` THEN REWRITE_TAC[] THEN
          SUBGOAL_THEN `abs(x + &m * &(flr fmt) ipow e) =
                            -- x - &m * &(flr fmt) ipow e`
          (fun thm -> REWRITE_TAC[thm]) THENL [
	    ASM_ARITH_TAC; ALL_TAC] THEN 
          REWRITE_TAC[finf] THEN ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `(x:real) - y < z <=> x < y + z`] THEN
	  USE_THEN "gmbig" (fun gmbig -> LABEL_TAC "mplus1"
          (MATCH_MP (ONCE_REWRITE_RULE[GSYM CONTRAPOS_THM] gmbig)
             (ARITH_RULE `~(m + 1 <= m)`))) THEN
          REWRITE_TAC[ARITH_RULE `(a:real) * b + b = (a + &1) * b`] THEN
          REWRITE_TAC[REAL_OF_NUM_ADD] THEN ASM_ARITH_TAC]);;
