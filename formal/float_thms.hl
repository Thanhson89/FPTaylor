(* ========================================================================== *)
(* FLOATING POINT THEOREMS                                                    *)
(* ========================================================================== *)

needs "float.hl";;

(* -------------------------------------------------------------------------- *)
(* Lemma. All fformats are valid.                                             *)
(* -------------------------------------------------------------------------- *)

let FFORMAT_SPLIT = TAUT `!(fmt:fformat). 
  (dest_fformat fmt) = (FST (dest_fformat fmt), SND (dest_fformat fmt))`;;

let FFORMAT_VALID = prove(`!(fmt:fformat). is_valid_format (dest_fformat fmt)`,
			  REWRITE_TAC[fformat_typbij]);;

let FFORMAT_RADIX_LT_1 =
  prove(`!(fmt:fformat). 1 < (fradix fmt)`,
	GEN_TAC THEN 
	  REWRITE_TAC[fradix] THEN 
	  ASSUME_TAC (
	    ONCE_REWRITE_RULE [is_valid_format] (
	      ONCE_REWRITE_RULE [FFORMAT_SPLIT] FFORMAT_VALID)) THEN
	  ASM_REWRITE_TAC[]);;

(* -------------------------------------------------------------------------- *)
(* Useful properties of ipow                                                  *)
(* -------------------------------------------------------------------------- *)

let NUM_OF_INT_EXISTS =
  prove(`!(i:int). &0 <= i ==> ?n. num_of_int(i) = n`,
	GEN_TAC THEN
	  DISCH_THEN(fun thm -> 
		       ASSUME_TAC(MATCH_MP INT_OF_NUM_OF_INT thm)) THEN
	  ASSUME_TAC(REWRITE_RULE
		       [num_of_int]
		       (ASSUME `&(num_of_int i) = i`)) THEN
	  ASSUME_TAC(CONV_RULE
		       SELECT_CONV
		       (ASSUME `&(@n. &n = (i:int)) = i`)) THEN
	  CHOOSE_TAC (GSYM(ASSUME `?n. &n = (i:int)`)) THEN
	  ONCE_ASM_REWRITE_TAC[] THEN
	  REWRITE_TAC[NUM_OF_INT_OF_NUM] THEN
	  EXISTS_TAC `(n:num)` THEN
	  ARITH_TAC);;

(* Lemma. For all x > 0, x^i > 0.                                             *)
let IPOW_POS =
  prove(`!(x:real) (i:int). &0 < x ==> &0 < x ipow i`,
	REPEAT GEN_TAC THEN
	  DISCH_TAC THEN
	  REWRITE_TAC[ipow] THEN
	  COND_CASES_TAC THENL [
	    MATCH_MP_TAC REAL_LT_INV THEN
	      ASSUME_TAC (MP
			    (ARITH_RULE `(i:int) < &0 ==> &0 <= (--i)`)
			    (ASSUME `(i:int) < &0`)) THEN
	      ASSUME_TAC (MATCH_MP
			    NUM_OF_INT_EXISTS
			    (ASSUME `&0 <= (--(i:int))`)) THEN
	      CHOOSE_TAC (ASSUME `?n. num_of_int(--(i:int)) = n`) THEN
	      ASM_REWRITE_TAC[] THEN
	      MATCH_MP_TAC REAL_POW_LT THEN
	      ASM_REWRITE_TAC[];
	      ALL_TAC] THEN
	  
	  ASSUME_TAC (MP
			(ARITH_RULE `~((i:int) < &0) ==> &0 <= i`)
			(ASSUME `~((i:int) < &0)`)) THEN
	  ASSUME_TAC (MATCH_MP
			NUM_OF_INT_EXISTS
			(ASSUME `&0 <= (i:int)`)) THEN
	  CHOOSE_TAC (ASSUME `?n. num_of_int(i:int) = n`) THEN
	  ASM_REWRITE_TAC[] THEN
	  MATCH_MP_TAC REAL_POW_LT THEN
	  ASM_REWRITE_TAC[]);;

(* Lemma. For all x > 0, y > 0, there is an i such that x^i < y.              *)
let IPOW_LT =
  prove(`!(x:real) (y:real). ?(i:int). x ipow i < y`,
	
			    

(* -------------------------------------------------------------------------- *)
(* Lemma. For any integer i and valid radix r, r^i > 0.                       *)
(* -------------------------------------------------------------------------- *)

let RADIX_IPOW_POS =
  prove(`!(fmt:fformat) (i:int). &0 < &(fradix fmt) ipow i`,
	REPEAT GEN_TAC THEN
	  MATCH_MP_TAC IPOW_POS THEN
	  ASSUME_TAC (MATCH_MP
			(ARITH_RULE `1 < x ==> 0 < x`)
			(SPEC `fmt:fformat` FFORMAT_RADIX_LT_1)) THEN

	  ASSUME_TAC (EQ_MP 
			(GSYM (SPECL 
				 [`0:num`;`(fradix fmt):num`] 
				 REAL_OF_NUM_LT))
			(ASSUME `0 < (fradix fmt)`)) THEN
	  ASM_REWRITE_TAC[]);;

(* -------------------------------------------------------------------------- *)
(* Lemma. If x is a non-zero fp number, then its fraction is non-zero.        *)
(* -------------------------------------------------------------------------- *)

let NONZERO_FRAC =
  prove(`!(fmt:fformat) (x:real) (f:num) (e:int).
	  ~(x = &0) /\ (frep(fmt) f e x) ==> 0 < f`,
	REWRITE_TAC[frep] THEN
	REPEAT GEN_TAC THEN
	  STRIP_TAC THEN
	  ASSUME_TAC(REWRITE_RULE
		       [REAL_ABS_NZ]
		       (ASSUME `~(x = &0)`)) THEN
	  REWRITE_TAC[GSYM(REAL_OF_NUM_LT)] THEN
	  ASSUME_TAC(MATCH_MP
		       (ARITH_RULE `&0 < a /\ a = b ==> &0 < b`)
		       (CONJ
			  (ASSUME `&0 < abs x`)
			  (ASSUME 
			     `abs x = &f * &(fradix fmt) ipow 
			      (e - &(fprec fmt) + &1)`))) THEN
	  ASSUME_TAC(EQ_MP
		       (SPECL [`&f`; `&(fradix fmt) ipow 
				 (e - &(fprec fmt) + &1)`] REAL_MUL_POS_LT)
		       (ASSUME `&0 < &f * &(fradix fmt) ipow 
			  (e - &(fprec fmt) + &1)`)) THEN
	  ASSUME_TAC (SPECL [`fmt:fformat`;
			     `(e - &(fprec fmt) + &1):int`]
			RADIX_IPOW_POS) THEN
	  ASM_ARITH_TAC);;


(* -------------------------------------------------------------------------- *)
(* Theorem. If x is a non-zero fp number, then there exists a unique          *)
(* normalized fraction and exponent for x.                                    *)
(* -------------------------------------------------------------------------- *)

let NORMALIZED_FRAC_EXISTS =
  prove(`!(fmt:fformat) (x:real) (f:num) (e:int). 
	  ~(x = &0) /\ (frep(fmt) f e x) ==> (is_norm_frac(fmt) f x)`,
	
