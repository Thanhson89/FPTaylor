(* ========================================================================== *)
(* FIXED POINT THEOREMS                                                       *)
(* ========================================================================== *)

needs "common.hl";;
needs "fixed.hl";;

(* -------------------------------------------------------------------------- *)
(* Valid fformat properties                                                   *)
(* -------------------------------------------------------------------------- *)

let FFORMAT_SPLIT = TAUT `!(fmt:fformat).
  (dest_fformat fmt) = (FST (dest_fformat fmt),
			(FST (SND (dest_fformat fmt)),
			 SND (SND (dest_fformat fmt))))`;;

let FFORMAT_VALID_IMP_RADIX_LT_1 =
  prove(`!(r:num) (p:num) (e:int). ((is_valid_fformat (r,p,e)) ==> 
				      1 < (FST (r,p,e)))`,
	REPEAT GEN_TAC THEN REWRITE_TAC[is_valid_fformat] THEN ARITH_TAC);;

let FFORMAT_VALID_IMP_RADIX_EVEN =
  prove(`!(r:num) (p:num) (e:int). ((is_valid_fformat (r,p,e)) ==> 
				      EVEN (FST (r,p,e)))`,
	REPEAT GEN_TAC THEN REWRITE_TAC[is_valid_fformat] THEN MESON_TAC[]);;

let FFORMAT_VALID_IMP_PREC_LT_0 =
  prove(`!(r:num) (p:num) (e:int). ((is_valid_fformat (r,p,e)) ==> 
				      0 < (FST (SND (r,p,e))))`,
	REPEAT GEN_TAC THEN REWRITE_TAC[is_valid_fformat] THEN MESON_TAC[]);;

let FFORMAT_VALID = 
  prove(`!(fmt:fformat). is_valid_fformat (dest_fformat fmt)`,
	REWRITE_TAC[fformat_typbij]);;

let FFORMAT_RADIX_LT_1 =
  prove(`!(fmt:fformat). 1 < (fr fmt)`,
	GEN_TAC THEN REWRITE_TAC[fr] THEN ONCE_REWRITE_TAC[FFORMAT_SPLIT] THEN
	  MATCH_MP_TAC FFORMAT_VALID_IMP_RADIX_LT_1 THEN
	  REWRITE_TAC[FFORMAT_VALID]);;

let FFORMAT_RADIX_LT_0 =
  prove(`!(fmt:fformat). 0 < (fr fmt)`,
	GEN_TAC THEN MATCH_MP_TAC (ARITH_RULE `1 < x ==> 0 < x`) THEN
        REWRITE_TAC[FFORMAT_RADIX_LT_1]);;

let FFORMAT_RADIX_NE_0 =
  prove(`!(fmt:fformat). ~(&(fr fmt) = &0)`,
	GEN_TAC THEN REWRITE_TAC[REAL_OF_NUM_EQ] THEN MATCH_MP_TAC 
        (ARITH_RULE `0 < x ==> ~(x = 0)`) THEN
        REWRITE_TAC[FFORMAT_RADIX_LT_0]);;

let FFORMAT_RADIX_EVEN =
  prove(`!(fmt:fformat). EVEN (fr fmt)`,
	GEN_TAC THEN REWRITE_TAC[fr] THEN ONCE_REWRITE_TAC[FFORMAT_SPLIT] THEN
	  MATCH_MP_TAC FFORMAT_VALID_IMP_RADIX_EVEN THEN
	  REWRITE_TAC[FFORMAT_VALID]);;

let FFORMAT_PREC_LT_0 =
  prove(`!(fmt:fformat). 0 < (fp fmt)`,
	GEN_TAC THEN REWRITE_TAC[fp] THEN ONCE_REWRITE_TAC[FFORMAT_SPLIT] THEN
	  MATCH_MP_TAC FFORMAT_VALID_IMP_PREC_LT_0 THEN
	  REWRITE_TAC[FFORMAT_VALID]);;

let FFORMAT_PREC_MINUS_1 =
  prove(`!(fmt:fformat). &0 <= (&(fp fmt):int) - (&1:int)`,
        REWRITE_TAC[ARITH_RULE `&0 <= x:int - &1:int <=> &1 <= x`] THEN
        REWRITE_TAC[INT_OF_NUM_LE] THEN
        REWRITE_TAC[ARITH_RULE `1 <= n <=> 0 < n`] THEN
	REWRITE_TAC[FFORMAT_PREC_LT_0]);;	

(* -------------------------------------------------------------------------- *)
(* Set of fixed point numbers is finite.                                      *)
(* -------------------------------------------------------------------------- *)

let FIXED_DISJOINT_CASES = 
  prove(`!(fmt:fformat) . (x IN fixed_inf(fmt)) <=> 
	  ((is_fixed(fmt) x) \/ x = (finf fmt) \/ x = --(finf fmt))`,
	GEN_TAC THEN REWRITE_TAC[fixed_inf] THEN REWRITE_TAC[UNION] THEN
	REWRITE_TAC[IN_ELIM_THM] THEN REWRITE_TAC[IN_INSERT] THEN
	REWRITE_TAC[NOT_IN_EMPTY]);;

let FIXED_CORR = define
  `fixed_corr (fmt:fformat) (n:num) = 
  (if (n = 0)
   then
     &0
   else if (ODD n)
   then
     -- &((n + 1) DIV 2) * &(fr fmt) ipow ((fe fmt) - &(fp fmt) + &1)
   else
     &(n DIV 2) * &(fr fmt) ipow ((fe fmt) - &(fp fmt) + &1))`;;

let FIXED_PREIMAGE = define
    `fixed_preimage (fmt:fformat) = 
  { n:num | 0 <= n /\ n <= 2 * (fr fmt) EXP ((fp fmt) - 1) }`;;

let FIXED_IN_IMAGE =
  prove(`!(fmt:fformat) (x:real). x IN (fixed_inf fmt) ==>
	  ?(n:num). n IN (fixed_preimage fmt) /\ (fixed_corr fmt n) = x`,
	REPEAT GEN_TAC THEN REWRITE_TAC[FIXED_CORR] THEN
	DISCH_THEN(fun thm -> 
	DISJ_CASES_THEN2 
	(* rewrite is_fixed *)
	(fun disj1 -> (CHOOSE_THEN (LABEL_TAC "frac") (REWRITE_RULE [is_frac] 
        (REWRITE_RULE [is_fixed] disj1))))
	(* rewrite +/- finf *)
	(fun disj2 -> DISJ_CASES_TAC (REWRITE_RULE [finf] disj2))
	(* disj cases thm *)
	(REWRITE_RULE [FIXED_DISJOINT_CASES] thm)) THENL [
	  (* case 1: x is a fixed point number *)
	  USE_THEN "frac" (fun frac ->
	  MAP_EVERY (fun pair -> (LABEL_TAC (fst pair) (snd pair)))
	  (zip ["frac1"; "frac2"] (CONJUNCTS frac))) THEN
	  ASM_CASES_TAC `&0 <= x` THENL [
	    (* case 1.1: x is non-negative *)
	    EXISTS_TAC `2 * f` THEN
	    COND_CASES_TAC THENL [
	      (* n = 0 *)
	      SUBGOAL_THEN `f = 0` (LABEL_TAC "f0") THENL [
		ASM_ARITH_TAC; ALL_TAC] THEN
	      USE_THEN "frac2" (fun frac2 -> USE_THEN "f0" (fun f0 ->
              LABEL_TAC "f0sub" (REWRITE_RULE [f0] frac2))) THEN
	      USE_THEN "f0sub" (fun f0sub -> LABEL_TAC "f0subsimp"
              (REWRITE_RULE[ARITH_RULE `&0 * x = &0`] f0sub)) THEN
	      USE_THEN "f0subsimp" (fun f0subsimp -> REWRITE_TAC
              [GSYM (REWRITE_RULE[REAL_ABS_ZERO] f0subsimp)]) THEN
	      REWRITE_TAC[FIXED_PREIMAGE] THEN REWRITE_TAC[IN_ELIM_THM] THEN
              ASM_ARITH_TAC;
	      COND_CASES_TAC THENL [
		(* n odd *)
                CONTR_TAC(REWRITE_RULE[DOUBLE_NOT_ODD] (ASSUME `ODD(2 * f)`));
		(* n even *)
		REWRITE_TAC[ARITH_RULE `(2 * z) DIV 2 = z`] THEN
                LABEL_TAC "absx" (REWRITE_RULE[GSYM REAL_ABS_REFL] 
                (ASSUME `&0 <= x`)) THEN
                USE_THEN "absx" (fun absx -> USE_THEN "frac2" (fun frac2 ->
                REWRITE_TAC[MATCH_MP EQ_TRANS (CONJ (GSYM absx) frac2)])) THEN
                REWRITE_TAC[FIXED_PREIMAGE] THEN REWRITE_TAC[IN_ELIM_THM] THEN
                ASM_ARITH_TAC]];

	    (* case 1.2: x is negative *)
	    SUBGOAL_THEN `0 < f` (LABEL_TAC "fpos") THENL [
	      LABEL_TAC "absn0" (MATCH_MP 
              (ARITH_RULE `~(&0 <= x) ==> ~(abs(x) = &0)`) 
              (ASSUME `~(&0 <= x)`)) THEN
              USE_THEN "absn0" (fun absn0 -> (USE_THEN "frac2" 
              (fun frac2 -> (LABEL_TAC "disjn0" (MATCH_MP REAL_MULT_NOT_0 
              (CONJ frac2 absn0)))))) THEN
	      USE_THEN "disjn0" (fun disjn0 -> (LABEL_TAC "fn0" 
              (REWRITE_RULE [REAL_OF_NUM_EQ] (CONJUNCT1 disjn0)))) THEN
              ASM_ARITH_TAC; ALL_TAC] THEN

	    EXISTS_TAC `2 * f - 1` THEN
	    COND_CASES_TAC THENL [
	      (* 2f - 1 = 0 *)
              ASM_ARITH_TAC;

	      COND_CASES_TAC THENL [
		(* 2f - 1 odd *)
		REWRITE_TAC[ARITH_RULE `(2 * f - 1 + 1) DIV 2 = f`] THEN
                SUBGOAL_THEN `x = -- abs(x)` (fun thm -> ONCE_REWRITE_TAC[thm])
                THENL [ASM_ARITH_TAC; ALL_TAC] THEN 
                USE_THEN "frac2" (fun frac2 -> REWRITE_TAC[ONCE_REWRITE_RULE
                [ARITH_RULE `(x:real) = y * z <=> --y * z = --x`] frac2]) THEN
                REWRITE_TAC[FIXED_PREIMAGE] THEN REWRITE_TAC[IN_ELIM_THM] THEN
                ASM_ARITH_TAC;

		(* 2f - 1 even *)
		USE_THEN "fpos" (fun fpos -> CONTR_TAC 
                (REWRITE_RULE [TAUT `~a /\ a <=> F`]
                (CONJ (ASSUME `~ODD(2 * f - 1)`) (MATCH_MP DOUBLE_NEG_1_ODD
                fpos))))]]];

	  (* x = +finf *)
          LABEL_TAC "eqexp" (MATCH_MP (SPEC `(fr fmt)` IPOW_EQ_EXP_P) 
          (SPEC `fmt:fformat` FFORMAT_PREC_LT_0)) THEN
          EXISTS_TAC `2 * (fr fmt) EXP (fp fmt - 1)` THEN
          COND_CASES_TAC THENL [
	    (* 2 * r^(p - 1) = 0 *)
	    SUBGOAL_THEN `~((fr fmt) EXP ((fp fmt) - 1) = 0)` (fun thm ->
            LABEL_TAC "expnot0" thm) THENL [
	      REWRITE_TAC[EXP_EQ_0] THEN REWRITE_TAC[ 
              MATCH_MP (ARITH_RULE `0 < x ==> ((x = 0) <=> F)`)
              (SPEC `fmt:fformat` FFORMAT_RADIX_LT_0)]; ALL_TAC] THEN
            ASM_ARITH_TAC;

	    COND_CASES_TAC THENL [
	      (* 2 * r^(p - 1) odd *)
	      CONTR_TAC(REWRITE_RULE[DOUBLE_NOT_ODD] 
              (ASSUME `ODD (2 * (fr fmt) EXP ((fp fmt) - 1))`));
	      (* 2 * r^(p - 1) even *)
	      REWRITE_TAC[ARITH_RULE `(2 * x) DIV 2 = x`] THEN
              USE_THEN "eqexp" (fun eqexp -> REWRITE_TAC [GSYM eqexp]) THEN
              REWRITE_TAC[MATCH_MP IPOW_ADD_EXP (SPEC `fmt:fformat` 
              FFORMAT_RADIX_NE_0)] THEN
	      REWRITE_TAC[ARITH_RULE `(x:int) - y + z - x + y = z`] THEN
	      ASM_REWRITE_TAC[] THEN REWRITE_TAC[FIXED_PREIMAGE] THEN
              REWRITE_TAC[IN_ELIM_THM] THEN 
              ARITH_TAC]];

	  (* x = -finf *)
          LABEL_TAC "eqexp" (MATCH_MP (SPEC `(fr fmt)` IPOW_EQ_EXP_P) 
          (SPEC `fmt:fformat` FFORMAT_PREC_LT_0)) THEN
          EXISTS_TAC `2 * (fr fmt) EXP (fp fmt - 1) - 1` THEN
          COND_CASES_TAC THENL [
	    (* 2 * r^(p - 1) - 1 = 0 *)
	    SUBGOAL_THEN `~((fr fmt) EXP ((fp fmt) - 1) = 0)` (fun thm ->
            LABEL_TAC "expnot0" thm) THENL [
	      REWRITE_TAC[EXP_EQ_0] THEN REWRITE_TAC[ 
              MATCH_MP (ARITH_RULE `0 < x ==> ((x = 0) <=> F)`)
              (SPEC `fmt:fformat` FFORMAT_RADIX_LT_0)]; ALL_TAC] THEN
            ASM_ARITH_TAC;

	    COND_CASES_TAC THENL [
	      (* 2 * r^(p - 1) - 1 odd *)
	      REWRITE_TAC[ARITH_RULE `(2 * x - 1 + 1) DIV 2 = x`] THEN
              REWRITE_TAC[ARITH_RULE `-- x * y = -- (x * y)`] THEN
              USE_THEN "eqexp" (fun eqexp -> REWRITE_TAC [GSYM eqexp]) THEN
              REWRITE_TAC[MATCH_MP IPOW_ADD_EXP (SPEC `fmt:fformat` 
              FFORMAT_RADIX_NE_0)] THEN
	      REWRITE_TAC[ARITH_RULE `(x:int) - y + z - x + y = z`] THEN
	      ASM_REWRITE_TAC[] THEN REWRITE_TAC[FIXED_PREIMAGE] THEN
              REWRITE_TAC[IN_ELIM_THM] THEN 
              ARITH_TAC;
	      (* 2 * m even *)
              LABEL_TAC "notodd" 
              (ASSUME `~ODD(2 * (fr fmt) EXP ((fp fmt) - 1) - 1)`) THEN
              USE_THEN "notodd" (fun notodd -> CONTR_TAC
	      (REWRITE_RULE [TAUT `~a /\ a <=> F`]
              (CONJ notodd (MATCH_MP DOUBLE_NEG_1_ODD
              (REWRITE_RULE [GSYM EXP_LT_0]
              (DISJ1 (SPEC `fmt:fformat` (REWRITE_RULE[REAL_OF_NUM_EQ]
              FFORMAT_RADIX_NE_0)) `(fp fmt) - 1 = 0`))))))]]]);;

let FIXED_FINITE =
  prove(`!(fmt:fformat). FINITE(fixed_inf fmt)`,
	(* lemma 1 *)
	SUBGOAL_THEN `!(fmt:fformat). FINITE(fixed_preimage fmt)`
	(LABEL_TAC "lem1") THENL [
	  GEN_TAC THEN REWRITE_TAC[FIXED_PREIMAGE] THEN
          REWRITE_TAC[GSYM numseg] THEN REWRITE_TAC[FINITE_NUMSEG]; ALL_TAC]
	THEN
	(* lemma 2 *)
	SUBGOAL_THEN `!(fmt:fformat). 
		     FINITE({(y:real) | ?(n:num). n IN (fixed_preimage fmt) /\ 
			  y = (fixed_corr fmt n)})`
	(LABEL_TAC "lem2") THENL [
	  GEN_TAC THEN REWRITE_TAC[GSYM IMAGE] THEN 
	  MATCH_MP_TAC FINITE_IMAGE THEN USE_THEN "lem1" (fun lem1 ->
          REWRITE_TAC[lem1]); ALL_TAC] THEN
	(* lemma 3 *)
        SUBGOAL_THEN `!(fmt:fformat). (fixed_inf fmt) SUBSET
          {(y:real) | ?(n:num). n IN (fixed_preimage fmt) /\ 
	       y = (fixed_corr fmt n)}` (LABEL_TAC "lem3") THENL [
	    GEN_TAC THEN REWRITE_TAC[SUBSET] THEN
            GEN_REWRITE_TAC (RAND_CONV o ABS_CONV o RAND_CONV o 
            ONCE_DEPTH_CONV) [IN_ELIM_THM] THEN
            GEN_REWRITE_TAC (RAND_CONV o ABS_CONV o RAND_CONV o 
            RAND_CONV o ABS_CONV o RAND_CONV o ONCE_DEPTH_CONV) 
            [EQ_SYM_EQ] THEN REWRITE_TAC[SPEC `fmt:fformat`
            FIXED_IN_IMAGE]; ALL_TAC] THEN
	(* main result *)
	GEN_TAC THEN MATCH_MP_TAC FINITE_SUBSET THEN
	EXISTS_TAC `{y | ?n. n IN fixed_preimage fmt /\ 
			   y = fixed_corr fmt n}` THEN
	ASM_REWRITE_TAC[]);;

let FIXED_NONEMPTY =
  prove(`!(fmt:fformat). ~((fixed_inf fmt) = {})`,
	GEN_TAC THEN REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
	EXISTS_TAC `(&0):real` THEN REWRITE_TAC[fixed_inf] THEN
	REWRITE_TAC[UNION] THEN REWRITE_TAC[IN_ELIM_THM] THEN
        DISJ1_TAC THEN REWRITE_TAC[is_fixed] THEN REWRITE_TAC[is_frac] THEN
	EXISTS_TAC `0:num` THEN REWRITE_TAC[ARITH_RULE `&0 * x = &0`] THEN
	REWRITE_TAC[REWRITE_RULE [GSYM EXP_LT_0]
        (DISJ1 (SPEC `fmt:fformat` (REWRITE_RULE[REAL_OF_NUM_EQ]
        FFORMAT_RADIX_NE_0)) `(fp fmt) - 1 = 0`)] THEN
        ARITH_TAC);;

(* -------------------------------------------------------------------------- *)
(* glb/lub exist                                                              *)
(* -------------------------------------------------------------------------- *)

let FIXED_GLB_EXISTS =
   prove(`!(fmt:fformat) (x:real). abs(x) <= finf(fmt) ==>
	   ?(y:real). (glb(fmt) x) = y /\ (is_glb(fmt) x y)`,
	 REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "absx") THEN
	 REWRITE_TAC[glb] THEN
	 (* lemma: {z | z is fixed /\ z <= x} is finite. *)
	 SUBGOAL_THEN `FINITE({z | z <= x} INTER (fixed_inf fmt))`
         (LABEL_TAC "fin") THENL [
	   MATCH_MP_TAC FINITE_SUBSET THEN
	   EXISTS_TAC `(fixed_inf fmt)` THEN
	   REWRITE_TAC[FIXED_FINITE] THEN
	   REWRITE_TAC[INTER_SUBSET]; ALL_TAC] THEN
	 (* lemma: {z | z is fixed /\ z <= x} is non-empty. *)
	 SUBGOAL_THEN `~(({z | z <= x} INTER (fixed_inf fmt)) = {})`
	 (LABEL_TAC "notempty") THENL [
	   REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
	   EXISTS_TAC `--(finf fmt)` THEN REWRITE_TAC[INTER] THEN
	   REWRITE_TAC[IN_ELIM_THM] THEN
           USE_THEN "absx" (fun absx -> REWRITE_TAC[REWRITE_RULE
           [REAL_ABS_BOUNDS] absx]) THEN
	   REWRITE_TAC[fixed_inf] THEN REWRITE_TAC[UNION] THEN
           REWRITE_TAC[IN_ELIM_THM] THEN DISJ2_TAC THEN
	   REWRITE_TAC[IN_ELIM_THM] THEN REWRITE_TAC[IN_INSERT]; ALL_TAC] THEN
	 (* back to main result ... *)
	 USE_THEN "fin" (fun fin -> USE_THEN "notempty" (fun notempty ->
         LABEL_TAC "sup0" (MATCH_MP SUP_FINITE (CONJ fin notempty)))) THEN
	 EXISTS_TAC `sup ({z | z <= (x:real)} INTER (fixed_inf fmt))` THEN
	 REWRITE_TAC[] THEN REWRITE_TAC[is_glb] THEN REWRITE_TAC[is_lb] THEN
	 USE_THEN "sup0" (fun sup0 -> MAP_EVERY (fun pair ->
         LABEL_TAC (fst pair) (snd pair)) (zip ["sup1"; "sup2"] 
         (CONJUNCTS sup0))) THEN
	 USE_THEN "sup1" (fun sup1 -> REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM]
         (GEN_REWRITE_RULE (RAND_CONV o ONCE_DEPTH_CONV) [INTER] sup1)]) THEN
	 USE_THEN "sup2" (fun sup2 -> REWRITE_TAC[ONCE_REWRITE_RULE[
         TAUT `a /\ b <=> b /\ a`] (REWRITE_RULE[IN_ELIM_THM]
         (GEN_REWRITE_RULE (RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o
         ONCE_DEPTH_CONV) [INTER] sup2))]));;

(* It might be possible to re-use FIXED_GLB_EXISTS, but it would probably be  *)
(* tedious.                                                                   *)
let FIXED_LUB_EXISTS =
   prove(`!(fmt:fformat) (x:real). abs(x) <= finf(fmt) ==>
	   ?(y:real). (lub(fmt) x) = y /\ (is_lub(fmt) x y)`,
	 REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "absx") THEN
	 REWRITE_TAC[lub] THEN
	 (* lemma: {z | z is fixed /\ x <= z} is finite. *)
	 SUBGOAL_THEN `FINITE({z | x <= z} INTER (fixed_inf fmt))`
         (LABEL_TAC "fin") THENL [
	   MATCH_MP_TAC FINITE_SUBSET THEN
	   EXISTS_TAC `(fixed_inf fmt)` THEN
	   REWRITE_TAC[FIXED_FINITE] THEN
	   REWRITE_TAC[INTER_SUBSET]; ALL_TAC] THEN
	 (* lemma: {z | z is fixed /\ z <= x} is non-empty. *)
	 SUBGOAL_THEN `~(({z | x <= z} INTER (fixed_inf fmt)) = {})`
	 (LABEL_TAC "notempty") THENL [
	   REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
	   EXISTS_TAC `(finf fmt)` THEN REWRITE_TAC[INTER] THEN
	   REWRITE_TAC[IN_ELIM_THM] THEN
           USE_THEN "absx" (fun absx -> REWRITE_TAC[REWRITE_RULE
           [REAL_ABS_BOUNDS] absx]) THEN
	   REWRITE_TAC[fixed_inf] THEN REWRITE_TAC[UNION] THEN
           REWRITE_TAC[IN_ELIM_THM] THEN DISJ2_TAC THEN
	   REWRITE_TAC[IN_ELIM_THM] THEN REWRITE_TAC[IN_INSERT]; ALL_TAC] THEN
	 (* back to main result ... *)
	 USE_THEN "fin" (fun fin -> USE_THEN "notempty" (fun notempty ->
         LABEL_TAC "inf0" (MATCH_MP INF_FINITE (CONJ fin notempty)))) THEN
	 EXISTS_TAC `inf ({z | (x:real) <= z} INTER (fixed_inf fmt))` THEN
	 REWRITE_TAC[] THEN REWRITE_TAC[is_lub] THEN REWRITE_TAC[is_ub] THEN
	 USE_THEN "inf0" (fun inf0 -> MAP_EVERY (fun pair ->
         LABEL_TAC (fst pair) (snd pair)) (zip ["inf1"; "inf2"] 
         (CONJUNCTS inf0))) THEN
	 USE_THEN "inf1" (fun inf1 -> REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM]
         (GEN_REWRITE_RULE (RAND_CONV o ONCE_DEPTH_CONV) [INTER] inf1)]) THEN
	 USE_THEN "inf2" (fun inf2 -> REWRITE_TAC[ONCE_REWRITE_RULE[
         TAUT `a /\ b <=> b /\ a`] (REWRITE_RULE[IN_ELIM_THM]
         (GEN_REWRITE_RULE (RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o
         ONCE_DEPTH_CONV) [INTER] inf2))]));;
