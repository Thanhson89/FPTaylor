(* ========================================================================== *)
(* FIXED POINT THEOREMS                                                       *)
(* ========================================================================== *)

needs "common.hl";;
needs "fixed.hl";;

(* -------------------------------------------------------------------------- *)
(* Valid fformat properties                                                   *)
(* -------------------------------------------------------------------------- *)

let FFORMAT_SPLIT = TAUT `!(fmt:fformat).
  (dest_fformat fmt) = (FST (dest_fformat fmt),
			(FST (SND (dest_fformat fmt)),
			 SND (SND (dest_fformat fmt))))`;;

let FFORMAT_VALID_IMP_RADIX_LT_1 =
  prove(`!(r:num) (p:num) (e:int). ((is_valid_fformat (r,p,e)) ==> 
				      1 < (FST (r,p,e)))`,
	REPEAT GEN_TAC THEN REWRITE_TAC[is_valid_fformat] THEN ARITH_TAC);;

let FFORMAT_VALID_IMP_RADIX_EVEN =
  prove(`!(r:num) (p:num) (e:int). ((is_valid_fformat (r,p,e)) ==> 
				      EVEN (FST (r,p,e)))`,
	REPEAT GEN_TAC THEN REWRITE_TAC[is_valid_fformat] THEN MESON_TAC[]);;

let FFORMAT_VALID_IMP_PREC_LT_0 =
  prove(`!(r:num) (p:num) (e:int). ((is_valid_fformat (r,p,e)) ==> 
				      0 < (FST (SND (r,p,e))))`,
	REPEAT GEN_TAC THEN REWRITE_TAC[is_valid_fformat] THEN MESON_TAC[]);;

let FFORMAT_VALID = 
  prove(`!(fmt:fformat). is_valid_fformat (dest_fformat fmt)`,
	REWRITE_TAC[fformat_typbij]);;

let FFORMAT_RADIX_LT_1 =
  prove(`!(fmt:fformat). 1 < (fr fmt)`,
	GEN_TAC THEN REWRITE_TAC[fr] THEN ONCE_REWRITE_TAC[FFORMAT_SPLIT] THEN
	  MATCH_MP_TAC FFORMAT_VALID_IMP_RADIX_LT_1 THEN
	  REWRITE_TAC[FFORMAT_VALID]);;

let FFORMAT_RADIX_LT_0 =
  prove(`!(fmt:fformat). 0 < (fr fmt)`,
	GEN_TAC THEN MATCH_MP_TAC (ARITH_RULE `1 < x ==> 0 < x`) THEN
        REWRITE_TAC[FFORMAT_RADIX_LT_1]);;

let FFORMAT_RADIX_NE_0 =
  prove(`!(fmt:fformat). ~(&(fr fmt) = &0)`,
	GEN_TAC THEN REWRITE_TAC[REAL_OF_NUM_EQ] THEN MATCH_MP_TAC 
        (ARITH_RULE `0 < x ==> ~(x = 0)`) THEN
        REWRITE_TAC[FFORMAT_RADIX_LT_0]);;

let FFORMAT_RADIX_EVEN =
  prove(`!(fmt:fformat). EVEN (fr fmt)`,
	GEN_TAC THEN REWRITE_TAC[fr] THEN ONCE_REWRITE_TAC[FFORMAT_SPLIT] THEN
	  MATCH_MP_TAC FFORMAT_VALID_IMP_RADIX_EVEN THEN
	  REWRITE_TAC[FFORMAT_VALID]);;

let FFORMAT_PREC_LT_0 =
  prove(`!(fmt:fformat). 0 < (fp fmt)`,
	GEN_TAC THEN REWRITE_TAC[fp] THEN ONCE_REWRITE_TAC[FFORMAT_SPLIT] THEN
	  MATCH_MP_TAC FFORMAT_VALID_IMP_PREC_LT_0 THEN
	  REWRITE_TAC[FFORMAT_VALID]);;

let FFORMAT_PREC_MINUS_1 =
  prove(`!(fmt:fformat). &0 <= (&(fp fmt):int) - (&1:int)`,
        REWRITE_TAC[ARITH_RULE `&0 <= x:int - &1:int <=> &1 <= x`] THEN
        REWRITE_TAC[INT_OF_NUM_LE] THEN
        REWRITE_TAC[ARITH_RULE `1 <= n <=> 0 < n`] THEN
	REWRITE_TAC[FFORMAT_PREC_LT_0]);;

let FFORMAT_PREC_IPOW_EQ_EXP =
  prove(`!(fmt:fformat). &(fr fmt) ipow (&(fp fmt) - &1) = 
      &((fr fmt) EXP ((fp fmt) - 1))`,
	REPEAT GEN_TAC THEN MATCH_MP_TAC IPOW_EQ_EXP_P THEN
	REWRITE_TAC[FFORMAT_PREC_LT_0]);;

let FFORMAT_RADIX_IPOW_LE_0 =
  prove(`!(fmt:fformat) (e:int). &0 <= &(fr fmt) ipow e`,
	REPEAT GEN_TAC THEN
	MATCH_MP_TAC (ARITH_RULE `&0 < (x:real) ==> &0 <= x`) THEN
	MATCH_MP_TAC IPOW_LT_0 THEN
	REWRITE_TAC[REAL_OF_NUM_LT] THEN
	REWRITE_TAC[FFORMAT_RADIX_LT_0]);;

let FFORMAT_RADIX_IPOW_LT_0 =
  prove(`!(fmt:fformat) (e:int). &0 < &(fr fmt) ipow e`,
	REPEAT GEN_TAC THEN
	MATCH_MP_TAC IPOW_LT_0 THEN
	REWRITE_TAC[REAL_OF_NUM_LT] THEN
	REWRITE_TAC[FFORMAT_RADIX_LT_0]);;

let FFORMAT_RADIX_IPOW_NEQ_0 =
  prove(`!(fmt:fformat) (e:int). ~(&(fr fmt) ipow e = &0)`,
	REPEAT GEN_TAC THEN 
        MATCH_MP_TAC (ARITH_RULE `&0 < (x:real) ==> ~(x = &0)`) THEN
	MATCH_MP_TAC IPOW_LT_0 THEN
	REWRITE_TAC[REAL_OF_NUM_LT] THEN
        REWRITE_TAC[FFORMAT_RADIX_LT_0]);;

let FFORMAT_RADIX_IPOW_ADD_EXP =
  prove(`!(fmt:fformat) (u:int) (v:int). 
	&(fr fmt) ipow u * &(fr fmt) ipow v = &(fr fmt) ipow (u + v)`, 
	REPEAT GEN_TAC THEN MATCH_MP_TAC IPOW_ADD_EXP THEN
	REWRITE_TAC[FFORMAT_RADIX_NE_0]);;

(* -------------------------------------------------------------------------- *)
(* Set of fixed point numbers is finite.                                      *)
(* -------------------------------------------------------------------------- *)

let FIXED_NEG_SYM =
  prove(`!(fmt:fformat) (x:real). (x IN (fixed fmt)) <=> (-- x IN (fixed fmt))`,
	REPEAT GEN_TAC THEN REWRITE_TAC[fixed] THEN 
        REWRITE_TAC[IN_ELIM_THM] THEN REWRITE_TAC[is_fixed] THEN 
        REWRITE_TAC[is_frac] THEN 
        REWRITE_TAC[ARITH_RULE `abs(-- x) = abs(x)`]);;

let FIXED_FINF_IN_FIXED =
  prove(`!(fmt:fformat). ((finf fmt) IN (fixed fmt) /\ 
			    (-- (finf fmt)) IN (fixed fmt))`,
	GEN_TAC THEN 
	(* lemma: finf in fixed *)
	SUBGOAL_THEN `(finf fmt) IN (fixed fmt)` (LABEL_TAC "infixed") THENL [
	  REWRITE_TAC[finf; fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
	  REWRITE_TAC[is_fixed] THEN REWRITE_TAC[is_frac] THEN
	  EXISTS_TAC `(fr (fmt:fformat)) EXP ((fp fmt) - 1)` THEN
	  REWRITE_TAC[ARITH_RULE `(x:num) <= x`] THEN
	  REWRITE_TAC[GSYM(MATCH_MP (SPEC `(fr fmt)` IPOW_EQ_EXP_P)
          (SPEC `fmt:fformat` FFORMAT_PREC_LT_0))] THEN
	  REWRITE_TAC[MATCH_MP IPOW_ADD_EXP (SPEC `fmt:fformat` 
          FFORMAT_RADIX_NE_0)] THEN
          REWRITE_TAC[ARITH_RULE `(x:int) - (y:int) + (z:int) - x + y = z`] THEN
	  REWRITE_TAC[REWRITE_RULE[GSYM REAL_ABS_REFL] 
          (MATCH_MP (ARITH_RULE `&0 < (x:real) ==> &0 <= x`)
          (SPEC `(fe fmt)`
          (MATCH_MP IPOW_LT_0 (REWRITE_RULE[GSYM REAL_OF_NUM_LT]
          (SPEC `fmt:fformat` FFORMAT_RADIX_LT_0)))))]; ALL_TAC] THEN
	  (* main result *)
	  ASM_REWRITE_TAC[] THEN
          USE_THEN "infixed" (fun infixed -> REWRITE_TAC[ONCE_REWRITE_RULE[
          SPEC `fmt:fformat` FIXED_NEG_SYM] infixed]));;

let FIXED_FINF_BOUNDS =
  prove(`!(fmt:fformat) (x:real). x IN (fixed fmt) ==> -- (finf fmt) <= x /\
          x <= (finf fmt)`,
	REPEAT GEN_TAC THEN DISCH_THEN (fun thm -> CHOOSE_THEN 
        (LABEL_CONJUNCTS_TAC ["frac1"; "frac2"])
        (REWRITE_RULE[is_frac] (REWRITE_RULE[is_fixed]
        (REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed] thm))))) THEN
	SUBGOAL_THEN `&f * &(fr fmt) ipow ((fe fmt) - &(fp fmt) + &1) <=
                       (finf fmt)` (LABEL_TAC "leqfinf") THENL [
	  REWRITE_TAC[finf] THEN GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV)
          [ARITH_RULE `(fe fmt) = (&(fp fmt) - &1) + (fe fmt) - &(fp fmt) + &1`]
          THEN
          GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV) 
          [GSYM FFORMAT_RADIX_IPOW_ADD_EXP] THEN
	  ONCE_REWRITE_TAC[
            ARITH_RULE `(x:real) * y <= z * y <=> y * x <= y * z`] THEN
	  MATCH_MP_TAC REAL_LE_LMUL THEN
	  REWRITE_TAC[FFORMAT_RADIX_IPOW_LE_0] THEN
	  REWRITE_TAC[FFORMAT_PREC_IPOW_EQ_EXP] THEN
	  REWRITE_TAC[REAL_OF_NUM_LE] THEN
	  ASM_REWRITE_TAC[]; ALL_TAC] THEN
	CONJ_TAC THENL [
	  (* neg finf *)
	  ONCE_REWRITE_TAC[ARITH_RULE `-- (x:real) <= y <=> -- y <= x`] THEN
	  MATCH_MP_TAC REAL_LE_TRANS THEN
	  EXISTS_TAC `abs(x)` THEN
	  REWRITE_TAC[ARITH_RULE `-- (z:real) <= abs(z)`] THEN
	  ASM_REWRITE_TAC[];
	  (* pos finf *)
	  MATCH_MP_TAC REAL_LE_TRANS THEN
	  EXISTS_TAC `abs(x)` THEN
	  REWRITE_TAC[ARITH_RULE `(z:real) <= abs(z)`] THEN
	  ASM_REWRITE_TAC[]]);;

let FIXED_FRAC_LT_0 =
  prove(`!(fmt:fformat) (u:real) (f:num).
	  ~(u = &0) /\ (is_frac(fmt) u f) ==> 0 < f`,
	REPEAT GEN_TAC THEN DISCH_THEN (fun thm ->
        LABEL_CONJUNCTS_TAC ["a1"; "a2"; "a3"] (REWRITE_RULE[is_frac] thm)) THEN
	MATCH_MP_TAC (ARITH_RULE `~(f = 0) ==> 0 < f`) THEN
	REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
        USE_THEN "a1" (fun a1 -> USE_THEN "a3" (fun a3 ->
        REWRITE_TAC[MATCH_MP REAL_MULT_NOT_0
        (CONJ a3 (ONCE_REWRITE_RULE[ARITH_RULE 
        `~((u:real) = &0) <=> ~(abs(u) = &0)`] a1))])));;

let FIXED_CORR = define
  `fixed_corr (fmt:fformat) (n:num) = 
  (if (n = 0)
   then
     &0
   else if (ODD n)
   then
     -- &((n + 1) DIV 2) * &(fr fmt) ipow ((fe fmt) - &(fp fmt) + &1)
   else
     &(n DIV 2) * &(fr fmt) ipow ((fe fmt) - &(fp fmt) + &1))`;;

let FIXED_PREIMAGE = define
    `fixed_preimage (fmt:fformat) = 
  { n:num | 0 <= n /\ n <= 2 * (fr fmt) EXP ((fp fmt) - 1) }`;;

let FIXED_IN_IMAGE =
  prove(`!(fmt:fformat) (x:real). x IN (fixed fmt) ==>
	  ?(n:num). n IN (fixed_preimage fmt) /\ (fixed_corr fmt n) = x`,
	REPEAT GEN_TAC THEN REWRITE_TAC[FIXED_CORR] THEN
	DISCH_THEN(fun thm -> CHOOSE_THEN (LABEL_TAC "a1")
        (REWRITE_RULE[is_fixed] (REWRITE_RULE[IN_ELIM_THM] 
        (REWRITE_RULE[fixed] thm)))) THEN
        USE_THEN "a1" (fun a1 -> LABEL_CONJUNCTS_TAC ["frac1"; "frac2"] 
        (REWRITE_RULE[is_frac] a1)) THEN
	  ASM_CASES_TAC `&0 <= x` THENL [
	    (* case 1.1: x is non-negative *)
	    EXISTS_TAC `2 * f` THEN
	    COND_CASES_TAC THENL [
	      (* n = 0 *)
	      SUBGOAL_THEN `f = 0` (LABEL_TAC "f0") THENL [
		ASM_ARITH_TAC; ALL_TAC] THEN
	      USE_THEN "frac2" (fun frac2 -> USE_THEN "f0" (fun f0 ->
              LABEL_TAC "f0sub" (REWRITE_RULE [f0] frac2))) THEN
	      USE_THEN "f0sub" (fun f0sub -> LABEL_TAC "f0subsimp"
              (REWRITE_RULE[ARITH_RULE `&0 * x = &0`] f0sub)) THEN
	      USE_THEN "f0subsimp" (fun f0subsimp -> REWRITE_TAC
              [GSYM (REWRITE_RULE[REAL_ABS_ZERO] f0subsimp)]) THEN
	      REWRITE_TAC[FIXED_PREIMAGE] THEN REWRITE_TAC[IN_ELIM_THM] THEN
              ASM_ARITH_TAC;
	      COND_CASES_TAC THENL [
		(* n odd *)
                CONTR_TAC(REWRITE_RULE[DOUBLE_NOT_ODD] (ASSUME `ODD(2 * f)`));
		(* n even *)
		REWRITE_TAC[ARITH_RULE `(2 * z) DIV 2 = z`] THEN
                LABEL_TAC "absx" (REWRITE_RULE[GSYM REAL_ABS_REFL] 
                (ASSUME `&0 <= x`)) THEN
                USE_THEN "absx" (fun absx -> USE_THEN "frac2" (fun frac2 ->
                REWRITE_TAC[MATCH_MP EQ_TRANS (CONJ (GSYM absx) frac2)])) THEN
                REWRITE_TAC[FIXED_PREIMAGE] THEN REWRITE_TAC[IN_ELIM_THM] THEN
                ASM_ARITH_TAC]];

	    (* case 1.2: x is negative *)
            USE_THEN "a1" (fun a1 -> 
            LABEL_TAC "fpos" (MATCH_MP (SPEC `fmt:fformat` FIXED_FRAC_LT_0)
            (CONJ (MATCH_MP (ARITH_RULE `~(&0 <= x) ==> ~(x = &0)`)
            (ASSUME `~(&0 <= x)`)) a1))) THEN

	    EXISTS_TAC `2 * f - 1` THEN
	    COND_CASES_TAC THENL [
	      (* 2f - 1 = 0 *)
              ASM_ARITH_TAC;

	      COND_CASES_TAC THENL [
		(* 2f - 1 odd *)
		REWRITE_TAC[ARITH_RULE `(2 * f - 1 + 1) DIV 2 = f`] THEN
                SUBGOAL_THEN `x = -- abs(x)` (fun thm -> ONCE_REWRITE_TAC[thm])
                THENL [ASM_ARITH_TAC; ALL_TAC] THEN 
                USE_THEN "frac2" (fun frac2 -> REWRITE_TAC[ONCE_REWRITE_RULE
                [ARITH_RULE `(x:real) = y * z <=> --y * z = --x`] frac2]) THEN
                REWRITE_TAC[FIXED_PREIMAGE] THEN REWRITE_TAC[IN_ELIM_THM] THEN
                ASM_ARITH_TAC;

		(* 2f - 1 even *)
		USE_THEN "fpos" (fun fpos -> CONTR_TAC 
                (REWRITE_RULE [TAUT `~a /\ a <=> F`]
                (CONJ (ASSUME `~ODD(2 * f - 1)`) (MATCH_MP DOUBLE_NEG_1_ODD
                fpos))))]]]);;

let FIXED_FINITE =
  prove(`!(fmt:fformat). FINITE(fixed fmt)`,
	(* lemma 1 *)
	SUBGOAL_THEN `!(fmt:fformat). FINITE(fixed_preimage fmt)`
	(LABEL_TAC "lem1") THENL [
	  GEN_TAC THEN REWRITE_TAC[FIXED_PREIMAGE] THEN
          REWRITE_TAC[GSYM numseg] THEN REWRITE_TAC[FINITE_NUMSEG]; ALL_TAC]
	THEN
	(* lemma 2 *)
	SUBGOAL_THEN `!(fmt:fformat). 
		     FINITE({(y:real) | ?(n:num). n IN (fixed_preimage fmt) /\ 
			  y = (fixed_corr fmt n)})`
	(LABEL_TAC "lem2") THENL [
	  GEN_TAC THEN REWRITE_TAC[GSYM IMAGE] THEN 
	  MATCH_MP_TAC FINITE_IMAGE THEN USE_THEN "lem1" (fun lem1 ->
          REWRITE_TAC[lem1]); ALL_TAC] THEN
	(* lemma 3 *)
        SUBGOAL_THEN `!(fmt:fformat). (fixed fmt) SUBSET
          {(y:real) | ?(n:num). n IN (fixed_preimage fmt) /\ 
	       y = (fixed_corr fmt n)}` (LABEL_TAC "lem3") THENL [
	    GEN_TAC THEN REWRITE_TAC[SUBSET] THEN
            GEN_REWRITE_TAC (RAND_CONV o ABS_CONV o RAND_CONV o 
            ONCE_DEPTH_CONV) [IN_ELIM_THM] THEN
            GEN_REWRITE_TAC (RAND_CONV o ABS_CONV o RAND_CONV o 
            RAND_CONV o ABS_CONV o RAND_CONV o ONCE_DEPTH_CONV) 
            [EQ_SYM_EQ] THEN REWRITE_TAC[SPEC `fmt:fformat`
            FIXED_IN_IMAGE]; ALL_TAC] THEN
	(* main result *)
	GEN_TAC THEN MATCH_MP_TAC FINITE_SUBSET THEN
	EXISTS_TAC `{y | ?n. n IN fixed_preimage fmt /\ 
			   y = fixed_corr fmt n}` THEN
	ASM_REWRITE_TAC[]);;

let FIXED_NONEMPTY =
  prove(`!(fmt:fformat). ~((fixed fmt) = {})`,
	GEN_TAC THEN REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
	EXISTS_TAC `(&0):real` THEN REWRITE_TAC[fixed] THEN
	REWRITE_TAC[UNION] THEN REWRITE_TAC[IN_ELIM_THM] THEN
        REWRITE_TAC[is_fixed] THEN REWRITE_TAC[is_frac] THEN
	EXISTS_TAC `0:num` THEN REWRITE_TAC[ARITH_RULE `&0 * x = &0`] THEN
	REWRITE_TAC[REWRITE_RULE [GSYM EXP_LT_0]
        (DISJ1 (SPEC `fmt:fformat` (REWRITE_RULE[REAL_OF_NUM_EQ]
        FFORMAT_RADIX_NE_0)) `(fp fmt) - 1 = 0`)] THEN
        ARITH_TAC);;

(* -------------------------------------------------------------------------- *)
(* glb/lub exist                                                              *)
(* -------------------------------------------------------------------------- *)

let FIXED_GLB_EXISTS =
   prove(`!(fmt:fformat) (x:real). abs(x) <= finf(fmt) ==>
	   ?(y:real). (glb(fmt) x) = y /\ (is_glb(fmt) x y)`,
	 REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "absx") THEN
	 REWRITE_TAC[glb] THEN
	 (* lemma: {z | z is fixed /\ z <= x} is finite. *)
	 SUBGOAL_THEN `FINITE({z | z IN (fixed fmt) /\ z <= x})`
         (LABEL_TAC "fin") THENL [
	   MATCH_MP_TAC FINITE_SUBSET THEN
	   EXISTS_TAC `(fixed fmt)` THEN
	   REWRITE_TAC[FIXED_FINITE] THEN REWRITE_TAC[SUBSET] THEN
	   REWRITE_TAC[IN_ELIM_THM] THEN
	   REWRITE_TAC[TAUT `a /\ b ==> a`]; ALL_TAC] THEN
	 (* lemma: {z | z is fixed /\ z <= x} is non-empty. *)
	 SUBGOAL_THEN `~({z | z IN (fixed fmt) /\ z <= x} = {})`
	 (LABEL_TAC "notempty") THENL [
	   REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
	   EXISTS_TAC `--(finf fmt)` THEN REWRITE_TAC[INTER] THEN
	   REWRITE_TAC[IN_ELIM_THM] THEN
           USE_THEN "absx" (fun absx -> REWRITE_TAC[REWRITE_RULE
           [REAL_ABS_BOUNDS] absx]) THEN
	   REWRITE_TAC[FIXED_FINF_IN_FIXED]; ALL_TAC] THEN
	 (* back to main result ... *)
	 USE_THEN "fin" (fun fin -> USE_THEN "notempty" (fun notempty ->
         LABEL_TAC "sup0" (MATCH_MP SUP_FINITE (CONJ fin notempty)))) THEN
	 EXISTS_TAC `sup ({z | z IN (fixed fmt) /\ z <= (x:real)})` THEN
	 REWRITE_TAC[] THEN REWRITE_TAC[is_glb] THEN REWRITE_TAC[is_lb] THEN
	 USE_THEN "sup0" (fun sup0 -> LABEL_CONJUNCTS_TAC ["sup1"; "sup2"]
	 sup0) THEN
	 USE_THEN "sup1" (fun sup1 -> REWRITE_TAC[ONCE_REWRITE_RULE[IN_ELIM_THM]
         sup1]) THEN
	 USE_THEN "sup2" (fun sup2 -> REWRITE_TAC[ONCE_REWRITE_RULE[
	 IN_ELIM_THM] sup2]));;

(* It might be possible to re-use FIXED_GLB_EXISTS, but it would probably be  *)
(* tedious.                                                                   *)
let FIXED_LUB_EXISTS =
   prove(`!(fmt:fformat) (x:real). abs(x) <= finf(fmt) ==>
	   ?(y:real). (lub(fmt) x) = y /\ (is_lub(fmt) x y)`,
	 REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "absx") THEN
	 REWRITE_TAC[lub] THEN
	 (* lemma: {z | z is fixed /\ x <= z} is finite. *)
	 SUBGOAL_THEN `FINITE({z | z IN (fixed fmt) /\ x <= z})`
         (LABEL_TAC "fin") THENL [
	   MATCH_MP_TAC FINITE_SUBSET THEN
	   EXISTS_TAC `(fixed fmt)` THEN
	   REWRITE_TAC[FIXED_FINITE] THEN REWRITE_TAC[SUBSET] THEN
	   REWRITE_TAC[IN_ELIM_THM] THEN
	   REWRITE_TAC[TAUT `a /\ b ==> a`]; ALL_TAC] THEN
	 (* lemma: {z | z is fixed /\ z <= x} is non-empty. *)
	 SUBGOAL_THEN `~({z | z IN (fixed fmt) /\ x <= z} = {})`
	 (LABEL_TAC "notempty") THENL [
	   REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
	   EXISTS_TAC `(finf fmt)` THEN REWRITE_TAC[INTER] THEN
	   REWRITE_TAC[IN_ELIM_THM] THEN
           USE_THEN "absx" (fun absx -> REWRITE_TAC[REWRITE_RULE
           [REAL_ABS_BOUNDS] absx]) THEN
	   REWRITE_TAC[FIXED_FINF_IN_FIXED]; ALL_TAC] THEN
	 (* back to main result ... *)
	 USE_THEN "fin" (fun fin -> USE_THEN "notempty" (fun notempty ->
         LABEL_TAC "inf0" (MATCH_MP INF_FINITE (CONJ fin notempty)))) THEN
	 EXISTS_TAC `inf ({z | z IN (fixed fmt) /\ x <= (z:real)})` THEN
	 REWRITE_TAC[] THEN REWRITE_TAC[is_lub] THEN REWRITE_TAC[is_ub] THEN
	 USE_THEN "inf0" (fun inf0 -> LABEL_CONJUNCTS_TAC ["inf1"; "inf2"]
	 inf0) THEN
	 USE_THEN "inf1" (fun inf1 -> REWRITE_TAC[ONCE_REWRITE_RULE[IN_ELIM_THM]
         inf1]) THEN
	 USE_THEN "inf2" (fun inf2 -> REWRITE_TAC[ONCE_REWRITE_RULE[
	 IN_ELIM_THM] inf2]));;

let FIXED_PLUS_FULP_NNEG =
  prove(`!(fmt:fformat) (u:real) (f:num).
	  &0 <= u /\ (is_frac(fmt) u f) ==>
	  u + (fulp fmt) =
	      &(f + 1) * &(fr fmt) ipow ((fe fmt) - &(fp fmt) + &1)`,
	REPEAT GEN_TAC THEN DISCH_THEN (fun thm ->
        LABEL_CONJUNCTS_TAC ["a1"; "a2"; "a3"] (REWRITE_RULE[is_frac] thm)) THEN
	USE_THEN "a1" (fun a1 -> USE_THEN "a3" (fun a3 ->
        REWRITE_TAC[REWRITE_RULE[MATCH_MP (ARITH_RULE
        `&0 <= (x:real) ==> abs(x) = x`) a1] a3])) THEN
	REWRITE_TAC[fulp] THEN
	REWRITE_TAC[ARITH_RULE `(&x:real) * y + y = (&x + &1) * y`] THEN
	REWRITE_TAC[REAL_OF_NUM_ADD]);;

let FIXED_PLUS_FULP_NEG =
  prove(`!(fmt:fformat) (u:real) (f:num).
	  u < &0 /\ (is_frac(fmt) u f) ==>
	  u + (fulp fmt) =
	      -- &(f - 1) * &(fr fmt) ipow ((fe fmt) - &(fp fmt) + &1)`,
	REPEAT GEN_TAC THEN DISCH_THEN (fun thm ->
        LABEL_CONJUNCTS_TAC ["a1"; "a2"] thm) THEN
        USE_THEN "a2" (fun a2 -> LABEL_CONJUNCTS_TAC ["a3"; "a4"]
        (REWRITE_RULE[is_frac] a2)) THEN
	USE_THEN "a1" (fun a1 -> USE_THEN "a4" (fun a4 ->
        REWRITE_TAC[REWRITE_RULE[MATCH_MP (ARITH_RULE
        `(x:real) < &0 ==> (abs(x) = z <=> x = -- z)`) a1] a4])) THEN
	REWRITE_TAC[fulp] THEN
	REWRITE_TAC[ARITH_RULE `-- ((&x:real) * y) + y = -- (&x - &1) * y`] THEN
	USE_THEN "a1" (fun a1 -> USE_THEN "a2" (fun a2 ->
        LABEL_TAC "a5" (MATCH_MP FIXED_FRAC_LT_0 (CONJ (MATCH_MP (ARITH_RULE
        `(u:real) < &0 ==> ~(u = &0)`) a1) a2)))) THEN
        USE_THEN "a5" (fun a5 -> REWRITE_TAC[MATCH_MP REAL_OF_NUM_SUB
        (MATCH_MP (ARITH_RULE `0 < f ==> 1 <= f`) a5)]));;

let FIXED_FULP_DISTANCE =
  prove(`!(fmt:fformat) (u:real) (v:real).
	  (u IN (fixed fmt)) /\ (v IN (fixed fmt)) /\
	  (u <= v) /\ (v <= u + (fulp fmt)) ==>
	  (v = u \/ v = u + (fulp fmt))`,
	REPEAT GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC
        ["ufixed"; "vfixed"; "ulev"; "vlefulp"]) THEN
	USE_THEN "ufixed" (fun ufixed ->
        X_CHOOSE_THEN `f1:num` (LABEL_TAC "ufrac")
        (REWRITE_RULE[is_fixed] (REWRITE_RULE[IN_ELIM_THM]
        (REWRITE_RULE[fixed] ufixed)))) THEN
	USE_THEN "vfixed" (fun vfixed ->
        X_CHOOSE_THEN `f2:num` (LABEL_TAC "vfrac")
        (REWRITE_RULE[is_fixed] (REWRITE_RULE[IN_ELIM_THM]
        (REWRITE_RULE[fixed] vfixed)))) THEN
	USE_THEN "ufrac" (fun ufrac -> LABEL_CONJUNCTS_TAC ["ufrac1"; "ufrac2"]
        (REWRITE_RULE[is_frac] ufrac)) THEN
	USE_THEN "vfrac" (fun vfrac -> LABEL_CONJUNCTS_TAC ["vfrac1"; "vfrac2"]
        (REWRITE_RULE[is_frac] vfrac)) THEN
	ASM_CASES_TAC `&0 <= (u:real)` THENL [
	  (* u non-negative *)
	  LABEL_TAC "uge0" (ASSUME `&0 <= (u:real)`) THEN
	  USE_THEN "ulev" (fun ulev -> USE_THEN "uge0" (fun uge0 ->
          LABEL_TAC "vge0"
          (MATCH_MP REAL_LE_TRANS (CONJ uge0 ulev)))) THEN
	  SUBGOAL_THEN `&0 <= (u:real) /\ (is_frac(fmt) u f1)`
          (fun thm -> LABEL_TAC "ulp" (MATCH_MP FIXED_PLUS_FULP_NNEG thm)) 
          THENL [
	    ASM_REWRITE_TAC[]; ALL_TAC] THEN
	  USE_THEN "uge0" (fun uge0 -> USE_THEN "ufrac2" (fun ufrac2 ->
          LABEL_TAC "ueq" (REWRITE_RULE[MATCH_MP
          (ARITH_RULE `&0 <= (x:real) ==> abs(x) = x`) uge0] ufrac2))) THEN
	  USE_THEN "vge0" (fun vge0 -> USE_THEN "vfrac2" (fun vfrac2 ->
          LABEL_TAC "veq" (REWRITE_RULE[MATCH_MP
          (ARITH_RULE `&0 <= (x:real) ==> abs(x) = x`) vge0] vfrac2))) THEN
	  ASM_REWRITE_TAC[] THEN
	  REWRITE_TAC[REAL_EQ_MUL_RCANCEL] THEN
	  REWRITE_TAC[FFORMAT_RADIX_IPOW_NEQ_0] THEN
	  REWRITE_TAC[REAL_OF_NUM_EQ] THEN
	  MATCH_MP_TAC IPOW_BETWEEN THEN
	  EXISTS_TAC `&(fr fmt)` THEN
	  EXISTS_TAC `(fe fmt) - &(fp fmt) + (&1:int)` THEN
	  REWRITE_TAC[REAL_OF_NUM_ADD] THEN
	  USE_THEN "ulp" (fun ulp -> REWRITE_TAC[GSYM ulp]) THEN
	  USE_THEN "ueq" (fun ueq -> REWRITE_TAC[GSYM ueq]) THEN
	  USE_THEN "veq" (fun veq -> REWRITE_TAC[GSYM veq]) THEN
	  ASM_REWRITE_TAC[] THEN
	  REWRITE_TAC[REAL_OF_NUM_LT] THEN
	  REWRITE_TAC[FFORMAT_RADIX_LT_0];

	  (* u negative *)
	  LABEL_TAC "unleq0" (ASSUME `~(&0 <= (u:real))`) THEN
	  USE_THEN "unleq0" (fun unleq0 -> LABEL_TAC "ul0"
          (MATCH_MP (ARITH_RULE `~(&0 <= (x:real)) ==> x < &0`) unleq0)) THEN
	  USE_THEN "unleq0" (fun unleq0 -> USE_THEN "ufrac" (fun ufrac -> 
          LABEL_TAC "fgt0" (MATCH_MP
          (SPEC `fmt:fformat` FIXED_FRAC_LT_0) (CONJ
          (MATCH_MP (ARITH_RULE `~(&0 <= (u:real)) ==> ~(u = &0)`) unleq0)
          ufrac)))) THEN
	  USE_THEN "ul0" (fun ul0 -> USE_THEN "ufrac" (fun ufrac ->
          LABEL_TAC "ulp" (MATCH_MP FIXED_PLUS_FULP_NEG (CONJ ul0 ufrac)))) THEN
	  (* lemma: u + fulp <= 0 *)
	  SUBGOAL_THEN `(u:real) + (fulp fmt) <= &0` 
          (LABEL_TAC "ulpleq0") THENL [
	    ASM_REWRITE_TAC[] THEN
	    REWRITE_TAC[ARITH_RULE `(-- (a:real)) * b = -- (a * b)`] THEN 
	    REWRITE_TAC[ARITH_RULE `-- (x:real) <= &0 <=> &0 <= x`] THEN
	    REWRITE_TAC[ARITH_RULE `&0 <= (x:real) * y <=> &0 * y <= x * y`]
            THEN 
	    MATCH_MP_TAC REAL_LE_RMUL THEN
            REWRITE_TAC[FFORMAT_RADIX_IPOW_LE_0] THEN
	    USE_THEN "fgt0" (fun fgt0 -> REWRITE_TAC[GSYM(MATCH_MP
            REAL_OF_NUM_SUB (MATCH_MP
            (ARITH_RULE `0 < x ==> 1 <= x`) fgt0))]) THEN
	    REWRITE_TAC[ARITH_RULE `&0 <= (x:real) - &1 <=> &1 <= x`] THEN
	    REWRITE_TAC[REAL_OF_NUM_LE] THEN
	    ASM_ARITH_TAC; ALL_TAC] THEN
	  SUBGOAL_THEN `(v:real) <= &0` (LABEL_TAC "vle0") THENL [
	    MATCH_MP_TAC REAL_LE_TRANS THEN
	    EXISTS_TAC `u + (fulp fmt)` THEN
	    ASM_ARITH_TAC; ALL_TAC] THEN
	  ASM_REWRITE_TAC[] THEN
	  USE_THEN "ul0" (fun ul0 -> USE_THEN "ufrac2" (fun ufrac2 ->
          LABEL_TAC "ueq" (REWRITE_RULE[MATCH_MP
          (ARITH_RULE `(x:real) < &0 ==> (abs(x) = z <=> x = --z)`) ul0]
          ufrac2))) THEN
	  USE_THEN "vle0" (fun vle0 -> USE_THEN "vfrac2" (fun vfrac2 ->
          LABEL_TAC "veq" (REWRITE_RULE[MATCH_MP
          (ARITH_RULE `(x:real) <= &0 ==> (abs(x) = z <=> x = --z)`) vle0]
          vfrac2))) THEN
	  ASM_REWRITE_TAC[] THEN
	  REWRITE_TAC[ARITH_RULE `(-- (a:real) * b) = -- (a * b)`] THEN
	  REWRITE_TAC[REAL_EQ_NEG2] THEN
	  REWRITE_TAC[REAL_EQ_MUL_RCANCEL] THEN
	  REWRITE_TAC[FFORMAT_RADIX_IPOW_NEQ_0] THEN
	  USE_THEN "fgt0" (fun fgt0 -> REWRITE_TAC[GSYM(MATCH_MP
          REAL_OF_NUM_SUB (MATCH_MP
          (ARITH_RULE `0 < x ==> 1 <= x`) fgt0))]) THEN
	  REWRITE_TAC[ARITH_RULE `(x:real) = (y:real) - &1 <=> x + &1 = y`] THEN
	  REWRITE_TAC[REAL_OF_NUM_ADD] THEN
	  REWRITE_TAC[REAL_OF_NUM_EQ] THEN
	  ONCE_REWRITE_TAC[ARITH_RULE `((a:num) = b) <=> (b = a)`] THEN
	  MATCH_MP_TAC IPOW_BETWEEN THEN
	  EXISTS_TAC `&(fr fmt)` THEN
	  EXISTS_TAC `(fe fmt) - &(fp fmt) + &1` THEN
	  REWRITE_TAC[ARITH_RULE `((x:real) + &1) * y = x * y + &1 * y`] THEN
	  REWRITE_TAC[ARITH_RULE `(x:real) <= y + z <=> x - z <= y`] THEN
	  REWRITE_TAC[ARITH_RULE `(x:real) * z - &1 * z = (x - &1) * z`] THEN
	  ONCE_REWRITE_TAC[GSYM REAL_LE_NEG] THEN
	  REWRITE_TAC[ARITH_RULE `--((a:real) * b) = (--a) * b`] THEN
	  USE_THEN "fgt0" (fun fgt0 -> REWRITE_TAC[MATCH_MP
          REAL_OF_NUM_SUB (MATCH_MP (ARITH_RULE `0 < n ==> 1 <= n`) fgt0)]) THEN
	  USE_THEN "ulp" (fun ulp -> REWRITE_TAC[GSYM ulp]) THEN
	  REWRITE_TAC[ARITH_RULE `(--  (a:real)) * b = -- (a * b)`] THEN
	  USE_THEN "ueq" (fun ueq -> REWRITE_TAC[GSYM ueq]) THEN
	  USE_THEN "veq" (fun veq -> REWRITE_TAC[GSYM veq]) THEN
	  ASM_REWRITE_TAC[] THEN
	  REWRITE_TAC[REAL_OF_NUM_LT] THEN
	  REWRITE_TAC[FFORMAT_RADIX_LT_0]]);;

let FIXED_GREATEST_LEAST_DIST =
  prove(`!(fmt:fformat) (x:real). abs(x) <= (finf fmt) ==>
	  glb(fmt) x <= lub(fmt) x /\ lub(fmt) x <= glb(fmt) x + (fulp fmt)`,
	REPEAT GEN_TAC THEN DISCH_THEN (fun thm -> LABEL_TAC "absx" thm) THEN
	USE_THEN "absx" (fun absx -> X_CHOOSE_THEN `y1:real` 
	(LABEL_CONJUNCTS_TAC ["glbeq"; "isglb"]) (MATCH_MP
        (SPEC `fmt:fformat` FIXED_GLB_EXISTS) absx)) THEN
	USE_THEN "absx" (fun absx -> X_CHOOSE_THEN `y2:real` 
	(LABEL_CONJUNCTS_TAC ["lubeq"; "islub"]) (MATCH_MP
        (SPEC `fmt:fformat` FIXED_LUB_EXISTS) absx)) THEN
	ASM_REWRITE_TAC[] THEN
	CONJ_TAC THENL [
	  (* y1 <= y2 is easy *)
	  USE_THEN "isglb" (fun isglb -> LABEL_CONJUNCTS_TAC ["islb"; "isgreat"]
	  (REWRITE_RULE[is_glb] isglb)) THEN
	  USE_THEN "islub" (fun islub -> LABEL_CONJUNCTS_TAC ["isub"; "isleast"]
	  (REWRITE_RULE[is_lub] islub)) THEN
	  USE_THEN "islb" (fun islb -> LABEL_CONJUNCTS_TAC ["y1fixed"; "y1leqx"]
	  (REWRITE_RULE[is_lb] islb)) THEN
	  USE_THEN "isub" (fun isub -> LABEL_CONJUNCTS_TAC ["y2fixed"; "xleqy2"]
	  (REWRITE_RULE[is_ub] isub)) THEN
	  ASM_ARITH_TAC;
	
	(* y2 <= y1 + fulp is harder *)
	ASM_CASES_TAC `&0 <= (y1:real)` THENL [
	  (* y1 non-negative *)
	  LABEL_TAC "y1geq0" (ASSUME `&0 <= (y1:real)`) THEN
	  ASM_CASES_TAC `y1 < (finf fmt)` THENL [
	    (* this is the interesting case when y1 != finf *)
	    USE_THEN "isglb" (fun isglb -> LABEL_CONJUNCTS_TAC ["islb";
	    "isgreat"] (REWRITE_RULE[is_glb] isglb)) THEN
	    USE_THEN "islb" (fun islb -> LABEL_CONJUNCTS_TAC ["y1fixed";
	    "y1leqx"] (REWRITE_RULE[is_lb] islb)) THEN
	    USE_THEN "y1fixed" (fun y1fixed -> X_CHOOSE_THEN `f1:num`
            (LABEL_CONJUNCTS_TAC ["y1frac1"; "y1frac2"]) 
            (REWRITE_RULE[is_frac] (REWRITE_RULE[is_fixed]
            (REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed] y1fixed))))) THEN
	  (* lemma: f1 + 1 <= r^(p - 1) *)
	  SUBGOAL_THEN `f1 + 1 <= (fr fmt) EXP ((fp fmt) - 1)`
          (LABEL_TAC "f1leq") THENL [
	    MATCH_MP_TAC (ARITH_RULE `x < y ==> x + 1 <= y`) THEN
	    REWRITE_TAC[GSYM REAL_OF_NUM_LT] THEN
	    REWRITE_TAC[GSYM FFORMAT_PREC_IPOW_EQ_EXP] THEN
	    MATCH_MP_TAC REAL_LT_LCANCEL_IMP THEN
	    EXISTS_TAC `&(fr fmt) ipow ((fe fmt) - &(fp fmt) + &1)` THEN
	    REWRITE_TAC[FFORMAT_RADIX_IPOW_LT_0] THEN
	    REWRITE_TAC[MATCH_MP IPOW_ADD_EXP (SPEC `fmt:fformat` 
            FFORMAT_RADIX_NE_0)] THEN
	    REWRITE_TAC[ARITH_RULE `((x:int) - y + &1) + y - &1 = x`] THEN
	    REWRITE_TAC[GSYM finf] THEN
	    ONCE_REWRITE_TAC[ARITH_RULE `(a:real) * b = b * a`] THEN
	    USE_THEN "y1geq0" (fun y1geq0 -> USE_THEN "y1frac2" (fun y1frac2 ->
            REWRITE_TAC[GSYM(REWRITE_RULE[MATCH_MP (ARITH_RULE
            `&0 <= (x:real) ==> abs(x) = x`) y1geq0] y1frac2)])) THEN
	    ASM_REWRITE_TAC[]; ALL_TAC] THEN
	  (* lemma: y1 + fulp is a fixed point number *)
	  SUBGOAL_THEN `(y1 + (fulp fmt)) IN fixed(fmt)`
	  (LABEL_TAC "ulpfixed") THENL [
	    REWRITE_TAC[fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
	    REWRITE_TAC[is_fixed] THEN REWRITE_TAC[is_frac] THEN
	    EXISTS_TAC `f1 + 1` THEN ASM_REWRITE_TAC[] THEN
	    MATCH_MP_TAC (ARITH_RULE `&0 <= x /\ x = y ==> abs(x) = y`) THEN
	    CONJ_TAC THENL [
	      MATCH_MP_TAC (ARITH_RULE `&0 <= x /\ &0 <= y ==> &0 <= x + y`)
              THEN
	      ASM_REWRITE_TAC[] THEN REWRITE_TAC[fulp] THEN
              REWRITE_TAC[FFORMAT_RADIX_IPOW_LE_0];
	      MATCH_MP_TAC FIXED_PLUS_FULP_NNEG THEN
              ASM_REWRITE_TAC[] THEN REWRITE_TAC[is_frac] THEN
              ASM_REWRITE_TAC[]]; ALL_TAC] THEN

	  ASM_CASES_TAC `(y1 + (fulp fmt)) <= x` THENL [
	    (* contradiction in the positive case *)
	    LABEL_TAC "ulpleqx" (ASSUME `y1 + (fulp fmt) <= x`) THEN
	    (* lemma: y1 + fulp is a lower bound *)
	    SUBGOAL_THEN `is_lb(fmt) x (y1 + (fulp fmt))` (LABEL_TAC
            "ulpislb") THENL [
	      REWRITE_TAC[is_lb] THEN ASM_REWRITE_TAC[]; ALL_TAC] THEN
	    (* lemma: y1 is less than y1 + fulp *)
	    SUBGOAL_THEN `y1 < (y1 + (fulp fmt))` (LABEL_TAC "y1lequlp") THENL [
	      REWRITE_TAC[ARITH_RULE `x:real < x + y <=> &0 < y`] THEN
	      REWRITE_TAC[fulp] THEN
	      REWRITE_TAC[SPEC `fmt:fformat` FFORMAT_RADIX_IPOW_LT_0]; ALL_TAC]
	    THEN
	    USE_THEN "isgreat" (fun isgreat -> USE_THEN "ulpislb" 
            (fun ulpislb -> ASSUME_TAC  (MATCH_MP isgreat ulpislb))) THEN
	    ASM_ARITH_TAC;

	    (* y1 + fulp > x *)
	    LABEL_TAC "ulpgeqx" (MATCH_MP (ARITH_RULE
            `~((z:real) <= y) ==> y <= z`) (ASSUME `~(y1 + (fulp fmt) <= x)`))
            THEN
	    (* lemma: y1 + fulp is an upper bound *)
	    SUBGOAL_THEN `is_ub(fmt) x (y1 + (fulp fmt))` (LABEL_TAC
            "ulpisub") THENL [
	      REWRITE_TAC[is_ub] THEN ASM_REWRITE_TAC[]; ALL_TAC] THEN
	    USE_THEN "islub" (fun islub -> LABEL_CONJUNCTS_TAC ["islb";
            "isleast"] (REWRITE_RULE[is_lub] islub)) THEN
	    USE_THEN "isleast" (fun isleast -> MATCH_MP_TAC isleast) THEN
	    ASM_REWRITE_TAC[]];

	    (* y1 >= finf, so y1 = finf *)
	    SUBGOAL_THEN `y1 = (finf fmt)` (LABEL_TAC "eqinf") THENL [
	      REWRITE_TAC[ARITH_RULE `(x:real) = y <=> x <= y /\ y <= x`] THEN
              GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV)
              [ARITH_RULE `(x:real) <= y <=> ~(y < x)`] THEN
	      ASM_REWRITE_TAC[] THEN 
              MATCH_MP_TAC (ARITH_RULE `--(finf fmt) <= x /\ x <= (finf fmt) ==>
              x <= (finf fmt)`) THEN
              MATCH_MP_TAC FIXED_FINF_BOUNDS THEN
	      USE_THEN "isglb" (fun isglb -> REWRITE_TAC[
              (REWRITE_RULE[is_lb] (REWRITE_RULE[is_glb] isglb))]); ALL_TAC]
              THEN
              MATCH_MP_TAC (ARITH_RULE 
                `&0 <= z /\ (x:real) <= y ==> x <= y + z`) THEN
	      ASM_REWRITE_TAC[] THEN REWRITE_TAC[fulp] THEN
	      REWRITE_TAC[FFORMAT_RADIX_IPOW_LE_0] THEN
	      MATCH_MP_TAC (ARITH_RULE `--(finf fmt) <= x /\ x <= (finf fmt) ==>
              x <= (finf fmt)`) THEN
              MATCH_MP_TAC FIXED_FINF_BOUNDS THEN
	      USE_THEN "islub" (fun islub -> REWRITE_TAC[
              (REWRITE_RULE[is_ub] (REWRITE_RULE[is_lub] islub))])];

	  (* y1 negative *)
	  LABEL_TAC "y1neg" (REWRITE_RULE[ARITH_RULE `~(&0 <= y) <=> y < &0`]
          (ASSUME `~(&0 <= (y1:real))`)) THEN
	  USE_THEN "isglb" (fun isglb -> LABEL_CONJUNCTS_TAC ["islb";
	  "isgreat"] (REWRITE_RULE[is_glb] isglb)) THEN
	  USE_THEN "islb" (fun islb -> LABEL_CONJUNCTS_TAC ["y1fixed";
	  "y1leqx"] (REWRITE_RULE[is_lb] islb)) THEN
	  USE_THEN "y1fixed" (fun y1fixed -> X_CHOOSE_THEN `f1:num`
          (LABEL_CONJUNCTS_TAC ["y1frac0"])
          (REWRITE_RULE[is_fixed]
          (REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed] y1fixed)))) THEN
	  USE_THEN "y1frac0" (fun y1frac0 -> 
          (LABEL_CONJUNCTS_TAC ["y1frac1"; "y1frac2"]) (REWRITE_RULE[is_frac]
          y1frac0)) THEN
	  (* lemma: f1 > 0 *)
	  SUBGOAL_THEN `0 < f1` (LABEL_TAC "f1gt0") THENL [
	    MATCH_MP_TAC (SPEC `fmt:fformat` FIXED_FRAC_LT_0)
	    EXISTS_TAC `y1:real` THEN
	    ASM_REWRITE_TAC[] THEN
	    ASM_ARITH_TAC; ALL_TAC] THEN
	  (* lemma: f1 - 1 <= r^(p - 1) *)
	  SUBGOAL_THEN `f1 - 1 <= (fr fmt) EXP ((fp fmt) - 1)`
          (LABEL_TAC "f1leq") THENL [
	    MATCH_MP_TAC (ARITH_RULE `x <= y ==> x - 1 <= y`) THEN
	    REWRITE_TAC[GSYM REAL_OF_NUM_LT] THEN
	    REWRITE_TAC[GSYM FFORMAT_PREC_IPOW_EQ_EXP] THEN
	    ASM_REWRITE_TAC[]; ALL_TAC] THEN
	  (* lemma: y1 + fulp is a fixed point number *)
	  SUBGOAL_THEN `(y1 + (fulp fmt)) IN fixed(fmt)`
	  (LABEL_TAC "ulpfixed") THENL [
	    REWRITE_TAC[fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
	    REWRITE_TAC[is_fixed] THEN REWRITE_TAC[is_frac] THEN
	    EXISTS_TAC `f1 - 1` THEN ASM_REWRITE_TAC[] THEN
	    MATCH_MP_TAC (ARITH_RULE `x <= &0 /\ -- x = y ==> abs(x) = y`) THEN
	    CONJ_TAC THENL [
	      USE_THEN "y1neg" (fun y1neg -> USE_THEN "y1frac0" (fun y1frac0 ->
              REWRITE_TAC[MATCH_MP FIXED_PLUS_FULP_NEG (CONJ y1neg y1frac0)])) 
              THEN
              REWRITE_TAC[ARITH_RULE 
                `(-- (a:real)) * b <= &0 <=> &0 <= a * b`] THEN
	      MATCH_MP_TAC REAL_LE_MUL THEN
              REWRITE_TAC[FFORMAT_RADIX_IPOW_LE_0] THEN
              REWRITE_TAC[REAL_OF_NUM_LE] THEN
              ARITH_TAC;
	      ONCE_REWRITE_TAC[ARITH_RULE 
                   `-- (x:real) = a * b <=> x = (-- a) * b`] THEN
	      MATCH_MP_TAC FIXED_PLUS_FULP_NEG THEN
              ASM_REWRITE_TAC[]]; ALL_TAC] THEN

	  ASM_CASES_TAC `(y1 + (fulp fmt)) <= x` THENL [
	    (* contradiction in the positive case *)
	    LABEL_TAC "ulpleqx" (ASSUME `y1 + (fulp fmt) <= x`) THEN
	    (* lemma: y1 + fulp is a lower bound *)
	    SUBGOAL_THEN `is_lb(fmt) x (y1 + (fulp fmt))` (LABEL_TAC
            "ulpislb") THENL [
	      REWRITE_TAC[is_lb] THEN ASM_REWRITE_TAC[]; ALL_TAC] THEN
	    (* lemma: y1 is less than y1 + fulp *)
	    SUBGOAL_THEN `y1 < (y1 + (fulp fmt))` (LABEL_TAC "y1lequlp") THENL [
	      REWRITE_TAC[ARITH_RULE `x:real < x + y <=> &0 < y`] THEN
	      REWRITE_TAC[fulp] THEN
	      REWRITE_TAC[SPEC `fmt:fformat` FFORMAT_RADIX_IPOW_LT_0]; ALL_TAC]
	    THEN
	    USE_THEN "isgreat" (fun isgreat -> USE_THEN "ulpislb" 
            (fun ulpislb -> ASSUME_TAC  (MATCH_MP isgreat ulpislb))) THEN
	    ASM_ARITH_TAC;

	    (* y1 + fulp > x *)
	    LABEL_TAC "ulpgeqx" (MATCH_MP (ARITH_RULE
            `~((z:real) <= y) ==> y <= z`) (ASSUME `~(y1 + (fulp fmt) <= x)`))
            THEN
	    (* lemma: y1 + fulp is an upper bound *)
	    SUBGOAL_THEN `is_ub(fmt) x (y1 + (fulp fmt))` (LABEL_TAC
            "ulpisub") THENL [
	      REWRITE_TAC[is_ub] THEN ASM_REWRITE_TAC[]; ALL_TAC] THEN
	    USE_THEN "islub" (fun islub -> LABEL_CONJUNCTS_TAC ["islb";
            "isleast"] (REWRITE_RULE[is_lub] islub)) THEN
	    USE_THEN "isleast" (fun isleast -> MATCH_MP_TAC isleast) THEN
	    ASM_REWRITE_TAC[]]]]);;
