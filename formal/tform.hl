needs "update_database.ml";;
needs "lib.hl";;

prioritize_real();;

parse_as_infix ("::", (12, "right"));;
override_interface ("::", `CONS`);;
make_overloadable "++" `:A->A->A`;;
overload_interface ("++", `APPEND`);;

let list_to_pair = function
  | [a; b] -> (a, b)
  | _ -> failwith "list_to_pair";;

let tform_exists = prove
  (`?s:(real^N->real) # ((real^N->real) # (real^N->real) # real)list. T`,
     REWRITE_TAC[]);;

let tform_type_bij = new_type_definition "tform" ("mk_tform", "dest_tform") tform_exists;;
let mk_tform, dest_tform = list_to_pair (CONJUNCTS (REWRITE_RULE[] tform_type_bij));;

let tform_f0 = new_definition `tform_f0 t = FST (dest_tform t)`;;
let tform_list = new_definition `tform_list t = SND (dest_tform t)`;;
let tform_dim = new_definition `tform_dim t = LENGTH (tform_list t)`;;

let tform_f1 = new_definition 
  `tform_f1 t = \x:real^N. sum_list (tform_list t) (\ (f1,e1,e2). f1 x * e1 x)`;;

let mul_f1 = new_definition
  `mul_f1 g list = MAP (\ (f1,e1,e2). (\x. g x * f1 x), e1, e2) list`;;

let dest_components = prove
  (`!t:(N)tform. dest_tform t = (tform_f0 t, tform_list t)`,
   REWRITE_TAC[tform_f0; tform_list]);;

let mk_components = prove
  (`!t:(N)tform. mk_tform (tform_f0 t, tform_list t) = t`,
   REWRITE_TAC[GSYM dest_components; mk_tform]);;

let f0_mk = prove
  (`!(f0:real^N->real) r. tform_f0 (mk_tform (f0, r)) = f0`,
   REWRITE_TAC[tform_f0; dest_tform]);;

let list_mk = prove
  (`!(f0:real^N->real) r. tform_list (mk_tform (f0, r)) = r`,
   REWRITE_TAC[tform_list; dest_tform]);;

let f1_mk = prove
  (`!(f0:real^N->real) r. tform_f1 (mk_tform (f0, r)) = \x. sum_list r (\ (f1,e1,e2). f1 x * e1 x)`,
   REWRITE_TAC[tform_f1; list_mk]);;

let approx = new_definition
  `approx (dom:real^N->bool) h (t:(N)tform) <=> 
    (!x. x IN dom ==> 
       h x = tform_f0 t x + tform_f1 t x /\
       ALL (\(f1, e1, e2). abs (e1 x) <= e2) (tform_list t))`;;


let triple_exists = prove
  (`!x'. ?(f1:real^N->real) (e1:real^N->real) (e2:real). x' = f1, e1, e2`,
   MESON_TAC[PAIR_SURJECTIVE]);;

let sum_list_mul1 = prove
  (`!g list (x:real^N). sum_list (mul_f1 g list) (\ (f1,e1,e2:real). (f1 x * e1 x)) = 
      g x * sum_list list (\ (f1,e1,e2). (f1 x * e1 x))`,
   REWRITE_TAC[mul_f1; sum_list_map; GSYM sum_list_lmul] THEN REPEAT GEN_TAC THEN
     MATCH_MP_TAC sum_list_eq THEN REWRITE_TAC[GSYM ALL_MEM] THEN REPEAT STRIP_TAC THEN
     STRIP_ASSUME_TAC (SPEC_ALL triple_exists) THEN ASM_REWRITE_TAC[o_THM; REAL_MUL_ASSOC]);;

let all_e12_mul1 = prove
  (`!g list P. ALL (\ (f1:real^N->real,e1:real^N->real,e2:real). P e1 e2) list ==> 
     ALL (\ (f1,e1,e2). P e1 e2) (mul_f1 g list)`,
   REPEAT GEN_TAC THEN REWRITE_TAC[GSYM ALL_MEM; mul_f1; MEM_MAP] THEN
     REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[] THEN POP_ASSUM (K ALL_TAC) THEN
     POP_ASSUM (fun th -> FIRST_X_ASSUM (MP_TAC o C MATCH_MP th)) THEN
     STRIP_ASSUME_TAC (SPEC_ALL triple_exists) THEN ASM_REWRITE_TAC[]);;


let approx_subset = prove
  (`!r1 r2 h (t:(N)tform). 
     approx r1 h t /\ r2 SUBSET r1 ==> approx r2 h t`,
   REWRITE_TAC[approx; SUBSET] THEN REPEAT STRIP_TAC THEN
     FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_SIMP_TAC[]);;

let approx_bound_gen = prove
  (`!s h t. approx s h t  ==> 
     !x:real^N. x IN s ==> 
       abs (h x - tform_f0 t x)
          <= sum_list (tform_list t) (\ (f1, e1, e2). abs (f1 x) * e2)`,
   REWRITE_TAC[approx] THEN REPEAT STRIP_TAC THEN
     FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_REWRITE_TAC[] THEN STRIP_TAC THEN
     ASM_REWRITE_TAC[REAL_ARITH `(a + b) - a = b:real`; tform_f1] THEN
     MATCH_MP_TAC sum_list_abs_le THEN POP_ASSUM MP_TAC THEN REWRITE_TAC[GSYM ALL_EL] THEN
     REPEAT STRIP_TAC THEN FIRST_X_ASSUM (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[] THEN
     STRIP_ASSUME_TAC (SPEC `EL i (tform_list (t:(N)tform))` triple_exists) THEN
     ASM_REWRITE_TAC[REAL_ABS_MUL] THEN DISCH_TAC THEN
     MATCH_MP_TAC REAL_LE_LMUL THEN ASM_REWRITE_TAC[REAL_ABS_POS]);;


let approx_bound = prove
  (`!s s2 h t m. approx s h t /\
     s SUBSET s2 /\
     (!x. x IN s2 ==> sum_list (tform_list t) (\ (f1,e1,e2). abs (f1 x) * e2) <= m)
   ==> !x:real^N. x IN s ==> abs (h x - tform_f0 t x) <= m`,
   REWRITE_TAC[SUBSET] THEN REPEAT STRIP_TAC THEN
     MP_TAC (SPECL[`s:real^N->bool`; `h:real^N->real`; `t:(N)tform`] approx_bound_gen) THEN
     ASM_SIMP_TAC[] THEN
     DISCH_THEN (MP_TAC o SPEC `x:real^N`) THEN ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
     ASM_MESON_TAC[REAL_LE_TRANS]);;

let approx_bound_simple = prove
  (`!s s2 h t ms. approx s h t /\
     s SUBSET s2 /\
     (!x. x IN s2 ==> ALL2 (\ (f1,e1,e2) m.  abs (f1 x) * e2 <= m) (tform_list t) ms)
   ==> !x:real^N. x IN s ==> 
     abs (h x - tform_f0 t x) <= sum_list ms I`,
   REPEAT GEN_TAC THEN STRIP_TAC THEN
     MATCH_MP_TAC approx_bound THEN EXISTS_TAC `s2:real^N->bool` THEN
     ASM_REWRITE_TAC[] THEN REPEAT STRIP_TAC THEN
     MATCH_MP_TAC sum_list_le_gen THEN
     FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_REWRITE_TAC[I_THM] THEN
     REWRITE_TAC[all2_el] THEN REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
     STRIP_ASSUME_TAC (SPEC `EL i (tform_list (t:(N)tform))` triple_exists) THEN
     FIRST_X_ASSUM (MP_TAC o SPEC `i:num`) THEN ASM_SIMP_TAC[]);;

(* ---------------------------- *)
(* const                        *)
(* ---------------------------- *)

let approx_const = prove
  (`!s c. approx s (\x:real^N. c)
                   (mk_tform ((\x. c), []))`,
   REWRITE_TAC[approx; tform_f1; f0_mk; list_mk; sum_list_nil; ALL; REAL_ADD_RID]);;

(* ---------------------------- *)
(* var                          *)
(* ---------------------------- *)

let approx_var = prove
  (`!s i. approx s (\x:real^N. x$i)
                   (mk_tform ((\x. x$i), []))`,
   REWRITE_TAC[approx; tform_f1; f0_mk; list_mk; sum_list_nil; ALL; REAL_ADD_RID]);;


(* ---------------------------- *)
(* neg                          *)
(* ---------------------------- *)

let approx_neg = prove
  (`!s h t. approx s h t
     ==> approx s (\x:real^N. --h x) 
                  (mk_tform ((\x. --tform_f0 t x),
			     MAP (\ (f1,e1,e2). (\x. --f1 x), e1, e2) (tform_list t)))`,
   REWRITE_TAC[approx; tform_f1] THEN REPEAT STRIP_TAC THEN ASM_SIMP_TAC[f0_mk; list_mk] THENL [
     REWRITE_TAC[REAL_ARITH `(--(a + b) = --a + c) <=> --b = c`] THEN
       REWRITE_TAC[sum_list_map; sum_list_neg] THEN
       MATCH_MP_TAC sum_list_eq THEN REWRITE_TAC[GSYM ALL_EL] THEN REPEAT STRIP_TAC THEN
       STRIP_ASSUME_TAC (SPEC `EL i (tform_list (t:(N)tform))` triple_exists) THEN
       ASM_REWRITE_TAC[o_THM; REAL_MUL_LNEG];
     ALL_TAC
   ] THEN
     FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_REWRITE_TAC[] THEN
     REWRITE_TAC[GSYM ALL_EL; LENGTH_MAP] THEN REPEAT STRIP_TAC THEN
     FIRST_X_ASSUM (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[] THEN
     STRIP_ASSUME_TAC (SPEC `EL i (tform_list (t:(N)tform))` triple_exists) THEN
     ASM_SIMP_TAC[EL_MAP]);;

(* ---------------------------- *)
(* add                          *)
(* ---------------------------- *)

let approx_add = prove
  (`!s h1 h2 t1 t2. approx s h1 t1 /\ approx s h2 t2
     ==> approx s (\x:real^N. h1 x + h2 x)
                  (mk_tform ((\x. tform_f0 t1 x + tform_f0 t2 x),
			     tform_list t1 ++ tform_list t2))`,
   REWRITE_TAC[approx; tform_f1] THEN REPEAT STRIP_TAC THEN 
     ASM_SIMP_TAC[f0_mk; list_mk; ALL_APPEND] THEN
     REWRITE_TAC[sum_list_append] THEN REAL_ARITH_TAC);;

(* ---------------------------- *)
(* sub                          *)
(* ---------------------------- *)

let approx_sub = prove
  (`!s h1 h2 t1 t2. approx s h1 t1 /\ approx s h2 t2
     ==> approx s (\x:real^N. h1 x - h2 x)
                  (mk_tform ((\x. tform_f0 t1 x - tform_f0 t2 x),
			     tform_list t1 ++ MAP (\(f1,e1,e2). (\x. --f1 x), e1, e2) (tform_list t2)))`,
  REPEAT STRIP_TAC THEN REWRITE_TAC[real_sub] THEN
    ABBREV_TAC `f1 = MAP (\(f1,e1,e2). (\x:real^N. --f1 x),e1,e2) (tform_list t2)` THEN
    ABBREV_TAC `t3 = mk_tform ((\x:real^N. --tform_f0 t2 x), f1)` THEN
    SUBGOAL_THEN `f1 = tform_list (t3:(N)tform) /\ (!x. --tform_f0 t2 x = tform_f0 t3 x)` ASSUME_TAC THENL [
      EXPAND_TAC "t3" THEN REWRITE_TAC[f0_mk; list_mk];
      ALL_TAC
    ] THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC approx_add THEN ASM_REWRITE_TAC[] THEN
    EXPAND_TAC "t3" THEN EXPAND_TAC "f1" THEN MATCH_MP_TAC approx_neg THEN ASM_REWRITE_TAC[]);;

(* ---------------------------- *)
(* mul                          *)
(* ---------------------------- *)

let approx_mul = prove
  (`!s h1 h2 t1 t2 m2 e2. 
     approx s h1 t1 /\ approx s h2 t2 /\
     (!x. x IN s ==> abs (tform_f1 t1 x * tform_f1 t2 x) <= m2 * e2) /\ 
     &0 < e2
     ==> approx s (\x:real^N. h1 x * h2 x)
                  (mk_tform ((\x. tform_f0 t1 x * tform_f0 t2 x),
			     (mul_f1 (tform_f0 t2) (tform_list t1) ++
				mul_f1 (tform_f0 t1) (tform_list t2) ++
				[(\x. m2), (\x. (tform_f1 t1 x * tform_f1 t2 x) / m2), e2])))`,
   REWRITE_TAC[approx; tform_f1] THEN REPEAT GEN_TAC THEN ASM_SIMP_TAC[f0_mk; list_mk] THEN
     STRIP_TAC THEN GEN_TAC THEN DISCH_TAC THEN
     ABBREV_TAC `r = \x:real^N. tform_f1 t1 x * tform_f1 t2 x` THEN
     STRIP_TAC THENL [
       REWRITE_TAC[sum_list_append; sum_list_mul1] THEN
	 REWRITE_TAC[REAL_ARITH `(a + b) * (c + d) = a * c + c * b + a * d + b * d`] THEN
	 ASM_REWRITE_TAC[REAL_EQ_ADD_LCANCEL; sum_list_sing] THEN
	 SUBGOAL_THEN `m2 * r (x:real^N) / m2 = r x` MP_TAC THENL [
	   ASM_CASES_TAC `m2 = &0` THENL [
	     FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_REWRITE_TAC[REAL_MUL_LZERO] THEN
	       EXPAND_TAC "r" THEN REWRITE_TAC[tform_f1] THEN REAL_ARITH_TAC;
	     ALL_TAC
	   ] THEN
	     ASM_SIMP_TAC[REAL_ARITH `m2 * a / m2 = (m2 / m2) * a`; REAL_DIV_REFL; REAL_MUL_LID];
	   ALL_TAC
	 ] THEN
	 EXPAND_TAC "r" THEN SIMP_TAC[tform_f1];
       ALL_TAC
     ] THEN
     REWRITE_TAC[ALL_APPEND; ALL] THEN ASM_SIMP_TAC[all_e12_mul1] THEN
     ASM_CASES_TAC `m2 = &0` THENL [
       ASM_REWRITE_TAC[real_div; REAL_INV_0; REAL_MUL_RZERO] THEN
	 ASM_SIMP_TAC[REAL_ABS_0; REAL_LT_IMP_LE];
       ALL_TAC
     ] THEN
     MATCH_MP_TAC REAL_LE_LCANCEL_IMP THEN EXISTS_TAC `m2:real` THEN
     SUBGOAL_THEN `&0 < m2` ASSUME_TAC THENL [
       SUBGOAL_THEN `&0 <= m2 * e2` MP_TAC THENL [
	 FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC;
	 ALL_TAC
       ] THEN
	 ASM_SIMP_TAC[REAL_LE_MUL_EQ] THEN
	 POP_ASSUM MP_TAC THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     ASM_SIMP_TAC[REAL_ABS_DIV; REAL_ARITH `&0 < m2 ==> abs m2 = m2`] THEN
     REWRITE_TAC[REAL_ARITH `a * b / c = a / c * b`; real_div] THEN
     ASM_SIMP_TAC[REAL_MUL_RINV; REAL_MUL_LID]);;

(* ---------------------------- *)
(* rounding                     *)
(* ---------------------------- *)

let is_rnd = new_definition
  `is_rnd(e2, d2) dom rnd =
  (!x. x IN dom ==> 
     ?e d. abs d <= d2 /\ abs e <= e2 /\ rnd(x) = x * (&1 + e) + d)`;;

let select_rnd = new_definition
  `select_rnd(e2, d2) s rnd (f:A->real) =
  (@p. !x. x IN s ==> abs ((SND p) x) <= d2 /\ 
     abs ((FST p) x) <= e2 /\ 
     rnd(f x) = f x * (&1 + (FST p) x) + (SND p) x)`;;


let is_rnd_select = prove
  (`!rnd (f:A->real) s s2 e2 d2. is_rnd(e2, d2) s2 rnd /\
     (!x. x IN s ==> f x IN s2)
     ==> let e, d = select_rnd(e2,d2) s rnd f in
       (!x. x IN s ==> rnd (f x) = f x * (&1 + e x) + d x /\
	    abs (e x) <= e2 /\
	    abs (d x) <= d2)`,
   REWRITE_TAC[select_rnd] THEN REPEAT STRIP_TAC THEN
     LET_TAC THEN
     ABBREV_TAC `p = e:A->real,d:A->real` THEN
     SUBGOAL_THEN `e = FST (p:(A->real)#(A->real)) /\ d = (SND p)` (fun th -> REWRITE_TAC[th]) THENL [
       EXPAND_TAC "p" THEN REWRITE_TAC[];
       ALL_TAC
     ] THEN
     POP_ASSUM (K ALL_TAC) THEN
     EXPAND_TAC "p" THEN SELECT_ELIM_TAC THEN GEN_TAC THEN DISCH_TAC THEN
     UNDISCH_TAC `is_rnd(e2,d2) s2 rnd` THEN
     REWRITE_TAC[is_rnd; SKOLEM_THM_GEN] THEN
     DISCH_THEN (X_CHOOSE_THEN `e:real->real` MP_TAC) THEN
     DISCH_THEN (X_CHOOSE_THEN `d:real->real` ASSUME_TAC) THEN
     FIRST_X_ASSUM (MP_TAC o SPECL[`s:A->bool`; `d2:real`; `e2:real`; `rnd:real->real`; `f:A->real`; `(\x. (e:real->real) ((f:A->real) x)), (\x. (d:real->real) ((f:A->real) x))`]) THEN
     ASM_SIMP_TAC[]);;


let approx_rnd_0 = prove
  (`!s h t rnd d2 s2. approx s h t /\ is_rnd(&0,d2) s2 rnd /\
     (!x:real^N. x IN s ==> h x IN s2)
     ==> let e, d = select_rnd(&0,d2) s rnd h in
       approx s (rnd o h) 
	 (mk_tform (tform_f0 t,
		    ((\x. &1), d, d2 :: tform_list t)))`,
   REWRITE_TAC[approx; tform_f1] THEN REPEAT STRIP_TAC THEN ASM_SIMP_TAC[f0_mk; list_mk] THEN
     REPEAT LET_TAC THEN
     MP_TAC (ISPECL[`rnd:real->real`; `h:real^N->real`; `s:real^N->bool`; `s2:real->bool`; `&0`; `d2:real`] is_rnd_select) THEN
     ASM_REWRITE_TAC[] THEN DISCH_THEN (ASSUME_TAC o CONV_RULE let_CONV) THEN
     GEN_TAC THEN DISCH_TAC THEN
     ABBREV_TAC `p = sum_list (tform_list (t:(N)tform)) (\(f1,e1,dd). f1 x * e1 x)` THEN
     REPEAT STRIP_TAC THEN ASM_SIMP_TAC[o_THM; sum_list_cons; ALL] THEN
     SUBGOAL_THEN `(e:real^N->real) x = &0` ASSUME_TAC THENL [
       FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_REWRITE_TAC[] THEN
	 REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC);;

let approx_rnd_alt = prove
  (`!s h t rnd e2 d2 s2 m2. approx s h t /\ is_rnd(e2,d2) s2 rnd /\
     (!x:real^N. x IN s ==> h x IN s2) /\
     (!x. x IN s ==> abs (tform_f1 t x) <= m2)
     ==> let e, d = select_rnd(e2,d2) s rnd h in
       approx s (rnd o h) 
	 (mk_tform (tform_f0 t,
		    ((tform_f0 t, e, e2) :: ((\x. m2), (\x. (e x * tform_f1 t x) / m2), e2) 
		     :: ((\x. &1), d, d2) :: tform_list t)))`,
   REWRITE_TAC[approx; tform_f1] THEN REPEAT STRIP_TAC THEN ASM_SIMP_TAC[f0_mk; list_mk] THEN
     REPEAT LET_TAC THEN
     MP_TAC ((SPEC_ALL o ISPECL[`rnd:real->real`; `h:real^N->real`]) is_rnd_select) THEN
     ASM_REWRITE_TAC[] THEN DISCH_THEN (ASSUME_TAC o CONV_RULE let_CONV) THEN
     GEN_TAC THEN DISCH_TAC THEN
     ABBREV_TAC `p = sum_list (tform_list (t:(N)tform)) (\(f1,e1,dd). f1 x * e1 x)` THEN
     REPEAT STRIP_TAC THENL [
       ASM_SIMP_TAC[o_THM; sum_list_cons] THEN
	 SUBGOAL_THEN `m2 * (e (x:real^N) * p) / m2 = e x * p` (fun th -> REWRITE_TAC[th]) THENL [
	   ASM_CASES_TAC `m2 = &0` THENL [
	     ASM_REWRITE_TAC[REAL_MUL_LZERO; EQ_SYM_EQ] THEN
	       REWRITE_TAC[REAL_ENTIRE] THEN DISJ2_TAC THEN
	       FIRST_X_ASSUM (K ALL_TAC o SPEC `x:real^N`) THEN
	       FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_REWRITE_TAC[] THEN
	       REAL_ARITH_TAC;
	     ALL_TAC
	   ] THEN
	     POP_ASSUM MP_TAC THEN CONV_TAC REAL_FIELD;
	   ALL_TAC
	 ] THEN
	 REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     ASM_SIMP_TAC[ALL] THEN
     ASM_CASES_TAC `m2 = &0` THENL [
       ASM_REWRITE_TAC[real_div; REAL_INV_0; REAL_MUL_RZERO; REAL_ABS_0] THEN
	 FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_REWRITE_TAC[] THEN
	 REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     REWRITE_TAC[REAL_ARITH `(a * b) / c = a * (b / c)`; REAL_ABS_MUL] THEN
     MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `e2 * &1` THEN
     CONJ_TAC THENL [ ALL_TAC; REAL_ARITH_TAC ] THEN
     MATCH_MP_TAC REAL_LE_MUL2 THEN ASM_SIMP_TAC[REAL_ABS_POS] THEN
     MATCH_MP_TAC REAL_LE_LCANCEL_IMP THEN EXISTS_TAC `abs m2` THEN
     CONJ_TAC THENL [ POP_ASSUM MP_TAC THEN REAL_ARITH_TAC; ALL_TAC ] THEN
     REWRITE_TAC[REAL_ABS_DIV; REAL_ARITH `a * b / c = (a / c) * b`] THEN
     ASM_SIMP_TAC[real_div; REAL_MUL_RINV; REAL_ABS_ZERO] THEN
     FIRST_X_ASSUM (K ALL_TAC o SPEC `x:real^N`) THEN
     FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_REWRITE_TAC[] THEN
     REAL_ARITH_TAC);;

let approx_rnd = prove
  (`!s h t rnd e2 d2 s2 m2. approx s h t /\ is_rnd(e2,d2) s2 rnd /\
     (!x:real^N. x IN s ==> h x IN s2) /\
     (!x. x IN s ==> abs (tform_f1 t x) <= m2) /\
     ~(e2 = &0)
     ==> let e, d = select_rnd(e2,d2) s rnd h in
         let r = (\x. e x * sum_list (tform_list t) (\ (f1,e1,dd). f1 x * e1 x) + d x) in
	   approx s (rnd o h) 
	     (mk_tform (tform_f0 t,
			CONS (tform_f0 t, e, e2)
			  (CONS ((\x. m2 + d2 / e2), (\x. r x / (m2 + d2 / e2)), e2)
			     (tform_list t))))`,
   REWRITE_TAC[approx; tform_f1] THEN REPEAT STRIP_TAC THEN ASM_SIMP_TAC[f0_mk; list_mk] THEN
     REPEAT LET_TAC THEN
     MP_TAC ((SPEC_ALL o ISPECL[`rnd:real->real`; `h:real^N->real`]) is_rnd_select) THEN
     ASM_REWRITE_TAC[] THEN DISCH_THEN (ASSUME_TAC o CONV_RULE let_CONV) THEN
     GEN_TAC THEN DISCH_TAC THEN
     ABBREV_TAC `p = sum_list (tform_list (t:(N)tform)) (\(f1,e1,dd). f1 x * e1 x)` THEN
     SUBGOAL_THEN `&0 <= m2 /\ &0 < e2 /\ &0 <= d2` (LABEL_TAC "ineqs") THENL [
       FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN
	 FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN
	 UNDISCH_TAC `~(e2 = &0)` THEN
	 ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     REPEAT STRIP_TAC THENL [
       ASM_SIMP_TAC[o_THM; sum_list_cons] THEN
	 SUBGOAL_THEN `(m2 + d2 / e2) * r (x:real^N) / (m2 + d2 / e2) = r x` (fun th -> REWRITE_TAC[th]) THENL [
	   ASM_CASES_TAC `m2 + d2 / e2 = &0` THENL [
	     SUBGOAL_THEN `m2 = &0 /\ d2 = &0` ASSUME_TAC THENL [
	       SUBGOAL_THEN `&0 <= d2 / e2` ASSUME_TAC THENL [
		 MATCH_MP_TAC REAL_LE_DIV THEN ASM_SIMP_TAC[REAL_LT_IMP_LE];
		 ALL_TAC
	       ] THEN
	       MP_TAC (REAL_ARITH `m2 + d2 / e2 = &0 /\ &0 <= m2 /\ &0 <= d2 / e2 ==> m2 = &0 /\ d2 / e2 = &0`) THEN
		 ASM_SIMP_TAC[] THEN
		 UNDISCH_TAC `~(e2 = &0)` THEN CONV_TAC REAL_FIELD;
	       ALL_TAC
	     ] THEN
	     ASM_REWRITE_TAC[REAL_MUL_LZERO; EQ_SYM_EQ] THEN EXPAND_TAC "r" THEN 
	       FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN
	       FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_REWRITE_TAC[] THEN
	       SIMP_TAC[REAL_ARITH `!t. abs t <= &0 ==> t = &0`] THEN REAL_ARITH_TAC;
	     ALL_TAC
	   ] THEN
	     POP_ASSUM MP_TAC THEN CONV_TAC REAL_FIELD;
	   ALL_TAC
	 ] THEN
	 EXPAND_TAC "r" THEN ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     ASM_SIMP_TAC[ALL] THEN
     ASM_CASES_TAC `m2 + d2 / e2 = &0` THENL [
       ASM_SIMP_TAC[real_div; REAL_INV_0; REAL_MUL_RZERO; REAL_ABS_0; REAL_LT_IMP_LE];
       ALL_TAC
     ] THEN
     EXPAND_TAC "r" THEN ASM_REWRITE_TAC[] THEN
     MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `abs ((e2 * m2 + e2 * d2 / e2) / (m2 + d2 / e2))` THEN
     CONJ_TAC THENL [
       REWRITE_TAC[REAL_ABS_DIV; real_div] THEN MATCH_MP_TAC REAL_LE_RMUL THEN
	 SIMP_TAC[REAL_LE_INV; REAL_ABS_POS] THEN
	 REWRITE_TAC[REAL_ARITH `e2 * d2 * inv e2 = (e2 * inv e2) * d2`] THEN
	 ASM_SIMP_TAC[REAL_MUL_RINV; REAL_MUL_LID] THEN
	 MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `e2 * m2 + d2` THEN
	 CONJ_TAC THENL [
	   MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `abs (e x * p) + abs (d (x:real^N))` THEN
	     REWRITE_TAC[REAL_ABS_TRIANGLE] THEN MATCH_MP_TAC REAL_LE_ADD2 THEN
	     ASM_SIMP_TAC[REAL_ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
	     FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN 
	     FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN
	     ASM_SIMP_TAC[REAL_ABS_POS];
	   ALL_TAC
	 ] THEN
	 SUBGOAL_THEN `&0 <= e2 * m2` MP_TAC THENL [
	   MATCH_MP_TAC REAL_LE_MUL THEN ASM_SIMP_TAC[REAL_LT_IMP_LE];
	   ALL_TAC
	 ] THEN
	 REMOVE_THEN "ineqs" MP_TAC THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     REWRITE_TAC[GSYM REAL_ADD_LDISTRIB; REAL_ARITH `(a * b) / b = a * b / b`] THEN
     ASM_SIMP_TAC[real_div; REAL_MUL_RINV; REAL_MUL_RID; REAL_ARITH `&0 < e2 ==> abs e2 <= e2`]);;


(* --------------------------- *)
(* Taylor 2                    *)
(* --------------------------- *)

let taylor2 = prove
  (`!f f' f'' a t.
     (!x. abs x <= abs t ==> 
	(f has_real_derivative f'(a + x)) (atreal (a + x)) /\
	(f' has_real_derivative f''(a + x)) (atreal (a + x)))
     ==> ?p. abs p <= abs t /\ 
             f(a + t) = f(a) + f'(a) * t + f''(a + p) * t pow 2 / &2`,
   REPEAT STRIP_TAC THEN
     ABBREV_TAC `g = \i. EL i [f:real->real; f'; f'']` THEN
     SUBGOAL_THEN `g 0 = (f:real->real) /\ g 1 = f' /\ g 2 = f''` ASSUME_TAC THENL [
       EXPAND_TAC "g" THEN REWRITE_TAC[ONE; TWO; EL; HD; TL];
       ALL_TAC
     ] THEN
     ASM_CASES_TAC `t = &0` THENL [
       EXISTS_TAC `&0` THEN ASM_REWRITE_TAC[REAL_LE_REFL] THEN
	 REWRITE_TAC[REAL_MUL_RZERO; REAL_ADD_RID; REAL_POW_2; real_div; REAL_MUL_LZERO];
       ALL_TAC
     ] THEN
     ASM_CASES_TAC `&0 < t` THENL [
       MP_TAC (SPECL[`g:num->real->real`; `a:real`; `a + t:real`; `1`] REAL_TAYLOR_MVT_POS) THEN
	 ANTS_TAC THENL [
	   CONJ_TAC THENL [ POP_ASSUM MP_TAC THEN REAL_ARITH_TAC; ALL_TAC ] THEN
	     REWRITE_TAC[IN_REAL_INTERVAL; ARITH_RULE `i <= 1 <=> i = 0 \/ i = 1`] THEN 
	     REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[ADD; ARITH_RULE `1 + 1 = 2`] THENL [
	       MATCH_MP_TAC HAS_REAL_DERIVATIVE_ATREAL_WITHIN THEN
		 FIRST_X_ASSUM (MP_TAC o SPEC `t' - a:real`) THEN 
		 ANTS_TAC THENL [ ASM_ARITH_TAC; ALL_TAC ] THEN
		 SIMP_TAC[REAL_ARITH `a + t' - a = t'`];
	       ALL_TAC
	     ] THEN
	     MATCH_MP_TAC HAS_REAL_DERIVATIVE_ATREAL_WITHIN THEN
	     FIRST_X_ASSUM (MP_TAC o SPEC `t' - a:real`) THEN 
	     ANTS_TAC THENL [ ASM_ARITH_TAC; ALL_TAC ] THEN
	     SIMP_TAC[REAL_ARITH `a + t' - a = t'`];
	   ALL_TAC
	 ] THEN
	 CONV_TAC ((ONCE_DEPTH_CONV EXPAND_SUM_CONV) THENC NUM_REDUCE_CONV) THEN
	 ASM_REWRITE_TAC[IN_REAL_INTERVAL; real_pow; REAL_POW_1] THEN STRIP_TAC THEN
	 EXISTS_TAC `t' - a:real` THEN
	 ASM_REWRITE_TAC[REAL_ARITH `!t. (a + t) - a = t /\ a + t - a = t`] THEN
	 ASM_ARITH_TAC;
       ALL_TAC
     ] THEN
     MP_TAC (SPECL[`g:num->real->real`; `a:real`; `a + t:real`; `1`] REAL_TAYLOR_MVT_NEG) THEN
     ANTS_TAC THENL [
       CONJ_TAC THENL [ ASM_ARITH_TAC; ALL_TAC ] THEN
	 REWRITE_TAC[IN_REAL_INTERVAL; ARITH_RULE `i <= 1 <=> i = 0 \/ i = 1`] THEN 
	 REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[ADD; ARITH_RULE `1 + 1 = 2`] THENL [
	   MATCH_MP_TAC HAS_REAL_DERIVATIVE_ATREAL_WITHIN THEN
	     FIRST_X_ASSUM (MP_TAC o SPEC `t' - a:real`) THEN 
	     ANTS_TAC THENL [ ASM_ARITH_TAC; ALL_TAC ] THEN
	     SIMP_TAC[REAL_ARITH `a + t' - a = t'`];
	   ALL_TAC
	 ] THEN
	 MATCH_MP_TAC HAS_REAL_DERIVATIVE_ATREAL_WITHIN THEN
	 FIRST_X_ASSUM (MP_TAC o SPEC `t' - a:real`) THEN 
	 ANTS_TAC THENL [ ASM_ARITH_TAC; ALL_TAC ] THEN
	 SIMP_TAC[REAL_ARITH `a + t' - a = t'`];
       ALL_TAC
     ] THEN
     CONV_TAC ((ONCE_DEPTH_CONV EXPAND_SUM_CONV) THENC NUM_REDUCE_CONV) THEN
     ASM_REWRITE_TAC[IN_REAL_INTERVAL; real_pow; REAL_POW_1] THEN STRIP_TAC THEN
     EXISTS_TAC `t' - a:real` THEN
     ASM_REWRITE_TAC[REAL_ARITH `!t. (a + t) - a = t /\ a + t - a = t`] THEN
     ASM_ARITH_TAC);;

	 
let taylor2_sin = prove
  (`!a t. ?p. abs p <= abs t /\ 
              sin (a + t) = sin a + cos a * t - sin (a + p) * t pow 2 / &2`,
   REPEAT STRIP_TAC THEN
     MP_TAC (SPECL[`sin`; `cos`; `\x. --sin x`; `a:real`; `t:real`] taylor2) THEN
     REWRITE_TAC[HAS_REAL_DERIVATIVE_SIN; HAS_REAL_DERIVATIVE_COS] THEN
     STRIP_TAC THEN EXISTS_TAC `p:real` THEN ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC);;

let taylor2_cos = prove
  (`!a t. ?p. abs p <= abs t /\
              cos (a + t) = cos a - sin a * t - cos (a + p) * t pow 2 / &2`,
   REPEAT STRIP_TAC THEN
     MP_TAC (SPECL[`cos`; `\x. --sin x`; `\x. --cos x`; `a:real`; `t:real`] taylor2) THEN
     ANTS_TAC THEN REPEAT STRIP_TAC THEN REWRITE_TAC[HAS_REAL_DERIVATIVE_COS] THENL [
       MATCH_MP_TAC HAS_REAL_DERIVATIVE_NEG THEN REWRITE_TAC[HAS_REAL_DERIVATIVE_SIN];
       ALL_TAC
     ] THEN
     EXISTS_TAC `p:real` THEN ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC);;

let taylor2_atn = prove
  (`!a t. ?p. abs p <= abs t /\
              atn (a + t) = atn a + inv (&1 + a pow 2) * t
                               - ((a + p) / (&1 + (a + p) pow 2) pow 2) * t pow 2`,
   REPEAT STRIP_TAC THEN
     MP_TAC (SPECL[`atn`; `\x. inv (&1 + x pow 2)`; `\x. -- &2 * x * inv (&1 + x pow 2) pow 2`; `a:real`; `t:real`] taylor2) THEN
     ANTS_TAC THEN REPEAT STRIP_TAC THEN REWRITE_TAC[HAS_REAL_DERIVATIVE_ATN] THENL [
       REAL_DIFF_TAC THEN ABBREV_TAC `r = a + x:real` THEN
	 REWRITE_TAC[ARITH_RULE `2 - 1 = 1`; REAL_POW_1; real_div; REAL_INV_POW] THEN
	 CONJ_TAC THENL [ ALL_TAC; REAL_ARITH_TAC ] THEN
	 MATCH_MP_TAC (REAL_ARITH `&0 <= x ==> ~(&1 + x = &0)`) THEN
	 REWRITE_TAC[REAL_LE_POW_2];
       ALL_TAC
     ] THEN
     EXISTS_TAC `p:real` THEN ASM_REWRITE_TAC[real_div; REAL_INV_POW] THEN
     REAL_ARITH_TAC);;

let taylor2_exp = prove
  (`!a t. ?p. abs p <= abs t /\
              exp (a + t) = exp a + exp a * t + exp (a + p) * t pow 2 / &2`,
   REPEAT STRIP_TAC THEN
     MP_TAC (SPECL[`exp`; `exp`; `exp`; `a:real`; `t:real`] taylor2) THEN
     REWRITE_TAC[HAS_REAL_DERIVATIVE_EXP] THEN
     STRIP_TAC THEN EXISTS_TAC `p:real` THEN ASM_REWRITE_TAC[]);;

let taylor2_inv = prove
  (`!a t. (!x. abs x <= abs t ==> ~(a + x = &0))
     ==> ?p. abs p <= abs t /\
             inv (a + t) = inv a - inv(a pow 2) * t + inv((a + p) pow 3) * t pow 2`,
   REPEAT STRIP_TAC THEN
     MP_TAC (SPECL[`inv`; `\x. --inv (x pow 2)`; `\x. &2 * inv (x pow 3)`; `a:real`; `t:real`] taylor2) THEN
     ANTS_TAC THEN REPEAT STRIP_TAC THENL [
       ASM_SIMP_TAC[HAS_REAL_DERIVATIVE_INV_BASIC];
       REAL_DIFF_TAC THEN ASM_SIMP_TAC[REAL_POW_2; REAL_ENTIRE] THEN
	 REWRITE_TAC[ARITH_RULE `2 - 1 = 1`; GSYM REAL_POW_2; REAL_POW_POW] THEN
	 REWRITE_TAC[REAL_ARITH `--(--(&2 * t * &1) / r) = &2 * (t / r)`] THEN
	 ASM_SIMP_TAC[REAL_DIV_POW2; ARITH_RULE `~(2 * 2 <= 1)`; ARITH_RULE `2 * 2 - 1 = 3`];
       ALL_TAC
     ] THEN
     EXISTS_TAC `p:real` THEN ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC);;

let taylor2_sqrt = prove
  (`!a t. (!x. abs x <= abs t ==> &0 < a + x)
     ==> ?p. abs p <= abs t /\
             sqrt (a + t) =  sqrt a + inv(sqrt a) * t / &2 - inv(sqrt (a + p) pow 3) * t pow 2 / &8`,
   REPEAT STRIP_TAC THEN
     MP_TAC (SPECL[`sqrt`; `\x. inv (&2 * sqrt x)`; `\x. --inv(&4 * sqrt x pow 3)`; `a:real`; `t:real`] taylor2) THEN
     ANTS_TAC THEN REPEAT STRIP_TAC THENL [
       ASM_SIMP_TAC[HAS_REAL_DERIVATIVE_SQRT];
       REAL_DIFF_TAC THEN ASM_SIMP_TAC[REAL_POW_2; REAL_ENTIRE] THEN
	 SUBGOAL_THEN `~(sqrt (a + x) = &0)` ASSUME_TAC THENL [
	   ASM_SIMP_TAC[SQRT_EQ_0; REAL_ARITH `&0 < t ==> ~(t = &0)`];
	   ALL_TAC
	 ] THEN
	 ASM_REWRITE_TAC[DE_MORGAN_THM; REAL_ARITH `~(&2 = &0)`] THEN
	 REWRITE_TAC[REAL_INV_MUL; real_div; REAL_INV_POW] THEN
	 REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     EXISTS_TAC `p:real` THEN ASM_REWRITE_TAC[REAL_INV_MUL; real_div] THEN
     REAL_ARITH_TAC);;

let taylor2_log = prove
  (`!a t. (!x. abs x <= abs t ==> &0 < a + x)
     ==> ?p. abs p <= abs t /\
             log (a + t) =  log a + inv a * t - inv((a + p) pow 2) * t pow 2 / &2`,
   REPEAT STRIP_TAC THEN
     MP_TAC (SPECL[`log`; `inv`; `\x. --inv(x pow 2)`; `a:real`; `t:real`] taylor2) THEN
     ANTS_TAC THEN REPEAT STRIP_TAC THENL [
       ASM_SIMP_TAC[HAS_REAL_DERIVATIVE_LOG];
       ASM_SIMP_TAC[HAS_REAL_DERIVATIVE_INV_BASIC; REAL_ARITH `&0 < t ==> ~(t = &0)`];
       ALL_TAC
     ] THEN
     EXISTS_TAC `p:real` THEN ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC);;


let approx_sin = prove
  (`!s h t m1 m2 e2 b. 
     (!x. x IN s ==> abs (tform_f1 t x) <= m1 /\ abs (tform_f1 t x pow 2) <= m2 * e2) /\
       (!x y. x IN s /\ abs y <= m1 ==> abs (sin (tform_f0 t x + y)) <= b) /\
       approx s h t /\
       ~(b = &0) /\ &0 <= m2 /\ &0 <= e2
     ==> approx s (\x:real^N. sin (h x))
       (mk_tform ((\x. sin (tform_f0 t x)),
		  (mul_f1 (\x. cos (tform_f0 t x)) (tform_list t) ++
		     [(\x. b * m2 / &2), 
		      (\x. (sin (h x) - sin (tform_f0 t x) - cos (tform_f0 t x) * tform_f1 t x) / 
			 (b * m2 / &2)),
		      e2])))`,
   REWRITE_TAC[approx; tform_f1] THEN REPEAT GEN_TAC THEN ASM_SIMP_TAC[f0_mk; list_mk] THEN
     STRIP_TAC THEN GEN_TAC THEN DISCH_TAC THEN
     ABBREV_TAC `r = sum_list (tform_list t) (\ (f1,e1,e2). f1 (x:real^N) * e1 x)` THEN
     STRIP_TAC THENL [
       REWRITE_TAC[sum_list_append; sum_list_mul1; sum_list_sing] THEN
	 ASM_CASES_TAC `(b * m2 / &2 = &0)` THENL [
	   ASM_REWRITE_TAC[real_div; REAL_INV_0; REAL_MUL_LZERO; REAL_ADD_RID] THEN
             SUBGOAL_THEN `r = &0` ASSUME_TAC THENL [
	       SUBGOAL_THEN `m2 = &0` ASSUME_TAC THENL [
		 POP_ASSUM MP_TAC THEN 
		   ASM_REWRITE_TAC[REAL_ENTIRE; real_div; REAL_ARITH `~(inv (&2) = &0)`];
		 ALL_TAC
	       ] THEN
		 REPEAT (FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`)) THEN
		 ASM_REWRITE_TAC[REAL_MUL_LZERO; REAL_ABS_MUL; REAL_POW_2] THEN
		 SUBGOAL_THEN `abs r * abs r <= &0 ==> r = &0` ASSUME_TAC THENL [
		   REWRITE_TAC[REAL_ARITH `a * b <= &0 <=> &0 <= (--a) * b`] THEN
		     REWRITE_TAC[REAL_MUL_POS_LE] THEN REAL_ARITH_TAC;
		   ALL_TAC
		 ] THEN
		 ASM_SIMP_TAC[];
	       ALL_TAC
	     ] THEN
	     ASM_REWRITE_TAC[REAL_ADD_RID; REAL_MUL_RZERO];
	   ALL_TAC
	 ] THEN
	 ASM_SIMP_TAC[REAL_ARITH `x * y / x = (x / x) * y`; REAL_DIV_REFL] THEN
         REAL_ARITH_TAC;
     ALL_TAC
   ] THEN
   ASM_SIMP_TAC[ALL_APPEND; all_e12_mul1; ALL] THEN
   STRIP_ASSUME_TAC (SPECL[`tform_f0 (t:(N)tform) x`; `r:real`] taylor2_sin) THEN
   ASM_REWRITE_TAC[REAL_ARITH `(a + b - c) - a - b = -- c`] THEN
   ASM_CASES_TAC `b * m2 / &2 = &0` THENL [
     ASM_REWRITE_TAC[real_div; REAL_INV_0; REAL_MUL_RZERO; REAL_ABS_0];
     ALL_TAC
   ] THEN
   MATCH_MP_TAC REAL_LE_LCANCEL_IMP THEN EXISTS_TAC `b * m2 / &2` THEN
   SUBGOAL_THEN `&0 <= b` ASSUME_TAC THENL [
     REPEAT (FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`)) THEN ASM_REWRITE_TAC[] THEN
       DISCH_TAC THEN DISCH_THEN (MP_TAC o SPEC `&0`) THEN
       MP_TAC (REAL_ARITH `abs r <= m1 ==> abs (&0) <= m1`) THEN
       ASM_SIMP_TAC[] THEN REAL_ARITH_TAC;
     ALL_TAC
   ] THEN
   CONJ_TAC THENL [
     MATCH_MP_TAC REAL_LT_MUL THEN
       POP_ASSUM MP_TAC THEN POP_ASSUM MP_TAC THEN
       REWRITE_TAC[REAL_ENTIRE; DE_MORGAN_THM] THEN
       UNDISCH_TAC `&0 <= m2` THEN REAL_ARITH_TAC;
     ALL_TAC
   ] THEN
   REWRITE_TAC[REAL_ABS_DIV; REAL_ABS_NEG; REAL_ABS_MUL; REAL_ABS_NUM] THEN
   SUBGOAL_THEN `abs b = b /\ abs m2 = m2` (fun th -> REWRITE_TAC[th]) THENL [
     ASM_REWRITE_TAC[REAL_ABS_REFL];
     ALL_TAC
   ] THEN
   ASM_SIMP_TAC[REAL_ARITH `x * y / x = (x / x) * y`; REAL_DIV_REFL; REAL_MUL_LID] THEN
   REWRITE_TAC[REAL_ARITH `(b * m2 / &2) * e2 = b * (m2 * e2) / &2`; real_div] THEN
   REWRITE_TAC[REAL_MUL_ASSOC] THEN MATCH_MP_TAC REAL_LE_RMUL THEN
   CONJ_TAC THENL [ ALL_TAC; REAL_ARITH_TAC ] THEN
   REWRITE_TAC[GSYM REAL_MUL_ASSOC] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
   EXPAND_TAC "r" THEN ASM_SIMP_TAC[REAL_ABS_POS] THEN
   FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[] THEN
   MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `abs r` THEN
   EXPAND_TAC "r" THEN ASM_SIMP_TAC[]);;


let approx_inv = prove
  (`!s h t m1 m2 e2 b. 
     (!x. x IN s ==> abs (tform_f1 t x) <= m1 /\ abs (tform_f1 t x pow 2) <= m2 * e2) /\
     (!x y. x IN s /\ abs y <= m1 ==> abs (inv ((tform_f0 t x + y) pow 3)) <= b /\
	                              ~(tform_f0 t x + y = &0)) /\
       approx s h t /\
       ~(b = &0) /\ &0 <= m2 /\ &0 <= e2
     ==> approx s (\x:real^N. inv (h x))
       (mk_tform ((\x. inv (tform_f0 t x)),
		  (mul_f1 (\x. --inv (tform_f0 t x pow 2)) (tform_list t) ++
		     [(\x. b * m2), 
		      (\x. (inv (h x) - inv (tform_f0 t x) + inv (tform_f0 t x pow 2) * tform_f1 t x) / 
			 (b * m2)),
		      e2])))`,
   REWRITE_TAC[approx; tform_f1] THEN REPEAT GEN_TAC THEN ASM_SIMP_TAC[f0_mk; list_mk] THEN
     STRIP_TAC THEN GEN_TAC THEN DISCH_TAC THEN
     ABBREV_TAC `r = sum_list (tform_list t) (\ (f1,e1,e2). f1 (x:real^N) * e1 x)` THEN
     STRIP_TAC THENL [
       REWRITE_TAC[sum_list_append; sum_list_mul1; sum_list_sing] THEN
	 ASM_CASES_TAC `(b * m2 = &0)` THENL [
	   ASM_REWRITE_TAC[real_div; REAL_INV_0; REAL_MUL_LZERO; REAL_ADD_RID] THEN
             SUBGOAL_THEN `r = &0` ASSUME_TAC THENL [
	       SUBGOAL_THEN `m2 = &0` ASSUME_TAC THENL [
		 POP_ASSUM MP_TAC THEN 
		   ASM_REWRITE_TAC[REAL_ENTIRE; real_div; REAL_ARITH `~(inv (&2) = &0)`];
		 ALL_TAC
	       ] THEN
		 REPEAT (FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`)) THEN
		 ASM_REWRITE_TAC[REAL_MUL_LZERO; REAL_ABS_MUL; REAL_POW_2] THEN
		 SUBGOAL_THEN `abs r * abs r <= &0 ==> r = &0` ASSUME_TAC THENL [
		   REWRITE_TAC[REAL_ARITH `a * b <= &0 <=> &0 <= (--a) * b`] THEN
		     REWRITE_TAC[REAL_MUL_POS_LE] THEN REAL_ARITH_TAC;
		   ALL_TAC
		 ] THEN
		 ASM_SIMP_TAC[];
	       ALL_TAC
	     ] THEN
	     ASM_REWRITE_TAC[REAL_ADD_RID; REAL_MUL_RZERO];
	   ALL_TAC
	 ] THEN
	 ASM_SIMP_TAC[REAL_ARITH `x * y / x = (x / x) * y`; REAL_DIV_REFL] THEN
         REAL_ARITH_TAC;
     ALL_TAC
   ] THEN
   ASM_SIMP_TAC[ALL_APPEND; all_e12_mul1; ALL] THEN
   MP_TAC (SPECL[`tform_f0 (t:(N)tform) x`; `r:real`] taylor2_inv) THEN ANTS_TAC THENL [
     GEN_TAC THEN DISCH_TAC THEN
       REPEAT (FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`)) THEN ASM_REWRITE_TAC[] THEN
       DISCH_TAC THEN DISCH_THEN (MP_TAC o SPEC `x':real`) THEN
       POP_ASSUM MP_TAC THEN POP_ASSUM MP_TAC THEN REAL_ARITH_TAC;
     ALL_TAC
   ] THEN
   STRIP_TAC THEN
   ASM_REWRITE_TAC[REAL_ARITH `(a - b + c) - a + b = c`] THEN
   ASM_CASES_TAC `b * m2 = &0` THENL [
     ASM_REWRITE_TAC[real_div; REAL_INV_0; REAL_MUL_RZERO; REAL_ABS_0];
     ALL_TAC
   ] THEN
   MATCH_MP_TAC REAL_LE_LCANCEL_IMP THEN EXISTS_TAC `b * m2` THEN
   SUBGOAL_THEN `&0 <= b` ASSUME_TAC THENL [
     REPEAT (FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`)) THEN ASM_REWRITE_TAC[] THEN
       DISCH_TAC THEN DISCH_THEN (MP_TAC o SPEC `&0`) THEN
       MP_TAC (REAL_ARITH `abs r <= m1 ==> abs (&0) <= m1`) THEN
       ASM_SIMP_TAC[] THEN REAL_ARITH_TAC;
     ALL_TAC
   ] THEN
   CONJ_TAC THENL [
     MATCH_MP_TAC REAL_LT_MUL THEN
       POP_ASSUM MP_TAC THEN POP_ASSUM MP_TAC THEN
       REWRITE_TAC[REAL_ENTIRE; DE_MORGAN_THM] THEN
       UNDISCH_TAC `&0 <= m2` THEN REAL_ARITH_TAC;
     ALL_TAC
   ] THEN
   REWRITE_TAC[REAL_ABS_DIV; REAL_ABS_NEG; REAL_ABS_MUL] THEN
   SUBGOAL_THEN `abs b = b /\ abs m2 = m2` (fun th -> REWRITE_TAC[th]) THENL [
     ASM_REWRITE_TAC[REAL_ABS_REFL];
     ALL_TAC
   ] THEN
   ASM_SIMP_TAC[REAL_ARITH `x * y / x = (x / x) * y`; REAL_DIV_REFL; REAL_MUL_LID] THEN
   REWRITE_TAC[GSYM REAL_MUL_ASSOC] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
   EXPAND_TAC "r" THEN ASM_SIMP_TAC[REAL_ABS_POS] THEN
   FIRST_X_ASSUM (MP_TAC o SPECL[`x:real^N`; `p:real`]) THEN ANTS_TAC THENL [
     ASM_REWRITE_TAC[] THEN
       MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `abs r` THEN 
       EXPAND_TAC "r" THEN ASM_SIMP_TAC[];
     ALL_TAC
   ] THEN
   SIMP_TAC[]);;
