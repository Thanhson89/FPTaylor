
(* ========================================================================= *)
(* Rounding Theorems                                                         *)
(* ========================================================================= *)

needs "../fptaylor-git/formal/ieee.hl";;

(* 
   Theorem: is_closest_exists
   
   Idea: Restrict to finite non-empty sets S, and prove by induction
   on S.
*)
let is_closest_exists = 
  prove(`!(v:A->real) (x:real) (S:A->bool). 
	  FINITE S /\ ~(S = {}) ==> ?a. is_closest v S x a`,
	(* Let v and x be arbitrary *)
	GEN_TAC THEN GEN_TAC THEN 
          (* Rewrite to: !S. FINITE S ==> ~(S = {}) ==> ?a ... *)
	  REWRITE_TAC[GSYM IMP_IMP] THEN
	  (* Proof by induction on finite set S *)
	  MATCH_MP_TAC FINITE_INDUCT THEN
	  (* Simple re-writes after substitution; base case done. *)
	  REWRITE_TAC[NOT_INSERT_EMPTY] THEN
	  (* Move induction hypothesis into assumptions. *)
	  REPEAT STRIP_TAC THEN
	  (* ---------- Case 1: s empty ---------- *)
	  ASM_CASES_TAC `(s:A->bool) = {}` THENL [
	    (* Use defn of is_closest *)
	    ASM_REWRITE_TAC[is_closest] THEN
	      (* a IN {x'} <=> a = x' ... *)
	      ASM_REWRITE_TAC[IN_SING] THEN
	      (* Take a = x'. *)
	      EXISTS_TAC `x':A` THEN 
	      REWRITE_TAC[] THEN
	      (* b = x' = a *)
	      REPEAT STRIP_TAC THEN 
	      ASM_REWRITE_TAC[REAL_LE_REFL];
	    ALL_TAC
	  ] THEN
	      (* ---------- Case 2: s non-empty ---------- *)
	      (* Apply MP to assumptions to reduce induction
		 hypothesis to ?a. is_closest v s x a, and then
		 apply MP_TAC to it. *)
	      POP_ASSUM (fun th -> FIRST_X_ASSUM (MP_TAC o C MATCH_MP th)) THEN
	    (* Use defn of is_closest and set insertion *)
	    REWRITE_TAC[is_closest; IN_INSERT] THEN 
	    STRIP_TAC THEN
	    (* ---------- Case 2.1: Min does not occur at x' ---------- *)
	    ASM_CASES_TAC `abs (v (a:A) - x) <= abs (v x' - x)` THENL [
	      EXISTS_TAC `a:A` THEN 
		ASM_MESON_TAC[];
	      ALL_TAC
	    ] THEN
	    (* ---------- Case 2.2: Min does occur at x' ---------- *)
	    EXISTS_TAC `x':A` THEN
	      ASM_MESON_TAC[REAL_LE_TRANS; REAL_NOT_LE; REAL_LT_IMP_LE]);;


let closest_lemma = prove(`!(v:A->real) P S x. FINITE S /\ ~(S = {})
			  ==> is_closest v S x (closest v P S x) /\
			  ((?b. is_closest v S x b /\ P b) ==> P (closest v P S x))`,
   REPEAT GEN_TAC THEN STRIP_TAC THEN REWRITE_TAC[closest] THEN
     CONV_TAC SELECT_CONV THEN
     ASM_CASES_TAC `?a:A. is_closest v S x a /\ P a` THENL [
       ASM_MESON_TAC[];
       ALL_TAC
     ] THEN
     ASM_MESON_TAC[is_closest_exists]);;
     
prove(`round X Float_to_zero (--x) = minus X (round X Float_to_zero x)`, ALL_TAC);;

prove(`&0 <= x ==> valof X (round X Float_to_zero x) <= x`, ALL_TAC);;

let nextf = define `(nextf X (0, e:num, f:num) = 
  if f < 2 EXP (fracwidth X) then 
    (0, e, f + 1) 
  else 
    (0, e + 1, 0))
    /\ (nextf X (1, e, f) =
  if 0 < f then
    (1, e, f - 1)
  else
    (1, e - 1, 2 EXP (fracwidth X) - 1))`;;

prove(`&0 <= x ==> x <= valof X (nextf X (round X Float_to_zero x))`, ALL_TAC);;

prove(`valof X (nextf X (0, e, f)) = valof X (0, e, f + 1)`, ALL_TAC);;

prove(`valof X (nextf X f) - valof X f = ulp X f`, ALL_TAC);;

(* define (onef X) s.t. valof X (onef X) = &1 /\ is_finite X (onef X) *)
prove(`ulp X f <= abs (valof X f) * ulp X (onef X)`, ALL_TAC);;

prove(`&0 <= x ==> ?e. &0 <= e /\ e <= ulp X (onef X)
	/\ valof X (round X Float_to_zero x) = x * (&1 - e)`, ALL_TAC);;

search[name "REAL_"];;
REAL_ARITH_TAC;;
