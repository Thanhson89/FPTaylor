needs "update_database.ml";;

needs "misc/misc_functions.hl";;
needs "ipow.hl";;
needs "tform.hl";;
needs "bin_float.hl";;

open Interval_arith;;
open Arith_float;;
open More_float;;
open Misc_functions;;
open Eval_interval;;


let tform_f1_bound = prove
  (`!s h t:(N)tform. approx s h t
   ==> (!x. x IN s ==> 
	  abs (tform_f1 t x) <= sum_list (tform_list t) (\ (f1, e1, e2). abs (f1 x) * e2))`,
   REWRITE_TAC[tform_f1; approx] THEN REPEAT STRIP_TAC THEN
     MATCH_MP_TAC sum_list_abs_le THEN REWRITE_TAC[GSYM ALL_EL] THEN REPEAT STRIP_TAC THEN
     MP_TAC (SPEC `EL i (tform_list (t:(N)tform))` triple_exists) THEN STRIP_TAC THEN
     ASM_REWRITE_TAC[REAL_ABS_MUL] THEN
     MATCH_MP_TAC REAL_LE_MUL2 THEN ASM_REWRITE_TAC[REAL_ABS_POS; REAL_LE_REFL] THEN
     FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_REWRITE_TAC[GSYM ALL_EL] THEN
     STRIP_TAC THEN FIRST_X_ASSUM (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[]);;


(*****************)

let create_domain =
  let comp_op = `($)` in
    fun pp list1 list2 ->
      let n = length (dest_list list1) in
      let sub_th0, (f_list1, f_list2) = M_verifier_main.mk_float_domain pp (list1, list2) in
      let dom_tm = lhand (concl sub_th0) in
      let x_tm = mk_var ("x", M_taylor.n_vector_type_array.(n)) in
      let x_comps = 
	let x_app = mk_icomb (comp_op, x_tm) in
	  map (fun i -> mk_comb (x_app, mk_small_numeral i)) (1--n) in
      let x_vec = M_taylor.mk_vector_list x_comps in
      let comp_th = end_itlist CONJ (Array.to_list M_taylor.comp_thms_array.(n)) in
      let x_eq = prove(mk_eq (x_tm, x_vec),
		       REWRITE_TAC[CART_EQ; M_taylor.dimindex_array.(n); 
				   M_taylor.gen_in_interval n; comp_th]) in
      let sub_th = GEN_REWRITE_RULE LAND_CONV [x_eq] 
	(UNDISCH (SPEC x_tm (REWRITE_RULE[SUBSET] sub_th0))) in
      let sub_th1 = REWRITE_RULE[IN_INTERVAL; M_taylor.dimindex_array.(n); 
				 M_taylor.gen_in_interval n] sub_th in
      let interval_ths = REWRITE_RULE[comp_th; GSYM interval_arith] sub_th1 in
      let vars = map (fun th ->
			let tm, _ = dest_interval_arith (concl th) in tm, th) 
	(CONJUNCTS interval_ths) in
	x_tm, dom_tm, vars;;

(**************)

let mk_ipow2 =
  let ipow2_const = `ipow2` in
    fun n ->
      let n_tm = mk_intconst n in
	mk_comb (ipow2_const, n_tm);;

let dest_mk_tform tm =
  match tm with
    | Comb (Const ("mk_tform", _), p_tm) ->
	dest_pair p_tm
    | _ -> error "dest_mk_tform" [tm] [];;

let dest_approx tm =
  match tm with
    | Comb (Comb (Comb (Const ("approx", _), s_tm), h_tm), mk_tm) ->
	s_tm, h_tm, dest_mk_tform mk_tm
    | _ -> error "dest_approx" [tm] [];;

let dest_f1_list tm =
  let el_tms = dest_list tm in
    map (fun tm ->
	   let tm1, rtm = dest_pair tm in
	   let tm2, tm3 = dest_pair rtm in
	     tm1, tm2, tm3) el_tms;;

let find_max_ipow2 tm =
  let _, _, (_, list_tm) = dest_approx tm in
  let e2_tms = map (fun (_, _, tm) -> tm) (dest_f1_list list_tm) in
  let ints = map (fun tm -> dest_intconst (rand tm)) e2_tms in
    if ints = [] then
      Int 0
    else
      itlist max_num (tl ints) (hd ints);;



let lemma_ipow2_mul = prove
  (`!n. a = ipow2 n * (a * ipow2 (--n))`,
   REWRITE_TAC[REAL_MUL_AC; GSYM ipow2_sub; INT_SUB_REFL; ipow2_0; REAL_MUL_RID]);;

let lemma_ipow2_0_mul = prove
  (`a = ipow2 (&0) * a`,
   REWRITE_TAC[ipow2_0; REAL_MUL_LID]);;

let lemma_trans = prove
  (`interval_arith x (lo, hi) /\ a <= ipow2 n * x
     ==> a <= hi * ipow2 n`,
   REWRITE_TAC[interval_arith] THEN STRIP_TAC THEN
     ONCE_REWRITE_TAC[REAL_MUL_AC] THEN
     MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `ipow2 n * x` THEN
     ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LE_LMUL THEN
     ASM_SIMP_TAC[ipow2_pos; REAL_LT_IMP_LE] THEN ASM_ARITH_TAC);;


(* Returns results in the form |- tform1 <= b * ipow2 k *)
let eval_tform1_bound pp approx_th dom_vars =
  let i = find_max_ipow2 (concl approx_th) in
  let th1 = MATCH_MP tform_f1_bound approx_th in
  let th2 = (UNDISCH_ALL o SPEC_ALL) th1 in
  let sum_tm = rand (concl th2) in
  let eq1_th =
    let conv1 = REWRITE_CONV[list_mk; sum_list_cons; sum_list_nil; REAL_ADD_RID] in
      if i =/ Int 0 then
	(conv1 THENC ONCE_REWRITE_CONV[lemma_ipow2_0_mul]) sum_tm
      else
	let conv2 = ONCE_REWRITE_CONV[SPEC (mk_intconst i) lemma_ipow2_mul] in
	let conv3 = REWRITE_CONV[REAL_ADD_RDISTRIB; GSYM REAL_MUL_ASSOC; GSYM ipow2_add] in
	let conv4 = REWRITE_CONV[ipow2_0; REAL_MUL_LID; REAL_MUL_RID; 
				 REAL_ADD_RID; REAL_ADD_LID] in
	  (conv1 THENC conv2 THENC conv3 THENC INT_REDUCE_CONV THENC conv4) sum_tm in
  let expr_tm1 = rand (rand (concl eq1_th)) in
  let conv5 = bin_float_rat_conv in
  let eq2_th = conv5 expr_tm1 in
  let eq_th = GEN_REWRITE_RULE (RAND_CONV o RAND_CONV) [eq2_th] eq1_th in
  let expr_tm2 = rand (concl eq2_th) in
  let ifun = build_interval_fun expr_tm2 in
  let expr_interval = eval_interval_fun pp ifun dom_vars [] in
  let r2 = REWRITE_RULE[eq_th] th2 in
  let t1 = CONJ expr_interval r2 in
    MATCH_MP lemma_trans t1;;



(**************)

(*
let pp = 5;;

let list1 = `[&1; &2]` and
    list2 = `[&3; sqrt (&5)]`;;


let s_tm, vars = create_domain list1 list2;;

let t1 = `mk_tform ((\x:real^2. x$1 + x$2),
		    [(\x. x$1), e1, ipow2 (-- &10);
		     (\x. x$2), e2, ipow2 (-- &12)])`;;

let a1' = mk_fthm ([], (mk_comb (`approx s (\x:real^2. x$1 + x$2)`, t1)));;
let a1 = INST[s_tm, `s:real^2->bool`] a1';;
*)
