needs "update_database.ml";;

needs "misc/misc_functions.hl";;
needs "ipow.hl";;
needs "tform.hl";;
needs "bin_float.hl";;

open Interval_arith;;
open Arith_float;;
open More_float;;
open Misc_functions;;
open Eval_interval;;

Hashtbl.add unary_interval_operations `abs` (fun pp th -> float_interval_abs th);;

prioritize_real();;

let ipow2 = new_definition `ipow2 (e:int) = &2 ipow e`;;

let ipow2_0 = prove
  (`ipow2 (&0) = &1`,
   REWRITE_TAC[ipow2; IPOW_0]);;

let ipow2_add = prove
  (`!e1 e2. ipow2 (e1 + e2) = ipow2 e1 * ipow2 e2`,
   ASM_SIMP_TAC[ipow2; IPOW_ADD; REAL_ARITH `~(&2 = &0)`]);;

let ipow2_sub = prove
  (`!e1 e2. ipow2 (e1 - e2) = ipow2 e1 * ipow2 (--e2)`,
   ASM_SIMP_TAC[ipow2; IPOW_SUB; REAL_ARITH `~(&2 = &0)`]);;

let ipow2_pos = prove
  (`!e. &0 < ipow2 e`,
   ASM_SIMP_TAC[ipow2; IPOW_LT_0; REAL_ARITH `&0 < &2`]);;

let ipow2_pos_num = prove
  (`!n. ipow2 (&n) = &2 pow n`,
   REWRITE_TAC[ipow2; IPOW_NUM]);;

let ipow2_neg_num = prove
  (`!n. ipow2 (-- &n) = inv (&2) pow n`,
   REWRITE_TAC[ipow2; IPOW_NEG; INV_IPOW; IPOW_NUM]);;


let tform_f1_bound = prove
  (`!s h t:(N)tform. approx s h t
   ==> (!x. x IN s ==> 
	  abs (tform_f1 t x) <= sum_list (tform_list t) (\ (f1, e1, e2). abs (f1 x) * e2))`,
   REWRITE_TAC[tform_f1; approx] THEN REPEAT STRIP_TAC THEN
     MATCH_MP_TAC sum_list_abs_le THEN REWRITE_TAC[GSYM ALL_EL] THEN REPEAT STRIP_TAC THEN
     MP_TAC (SPEC `EL i (tform_list (t:(N)tform))` triple_exists) THEN STRIP_TAC THEN
     ASM_REWRITE_TAC[REAL_ABS_MUL] THEN
     MATCH_MP_TAC REAL_LE_MUL2 THEN ASM_REWRITE_TAC[REAL_ABS_POS; REAL_LE_REFL] THEN
     FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_REWRITE_TAC[GSYM ALL_EL] THEN
     STRIP_TAC THEN FIRST_X_ASSUM (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[]);;


(*****************)

let pp = 5;;

let list1 = `[&1; &2]` and
    list2 = `[&3; sqrt (&5)]`;;

let create_domain list1 list2 =
  let n = length (dest_list list1) in
  let sub_th0, (f_list1, f_list2) = M_verifier_main.mk_float_domain pp (list1, list2) in
  let dom_tm = lhand (concl sub_th0) in
  let x_tm = mk_var ("x", M_taylor.n_vector_type_array.(n)) in
  let x_comps = 
    let x_app = mk_icomb (`($)`, x_tm) in
      map (fun i -> mk_comb (x_app, mk_small_numeral i)) (1--n) in
  let x_vec = M_taylor.mk_vector_list x_comps in
  let comp_th = end_itlist CONJ (Array.to_list M_taylor.comp_thms_array.(2)) in
  let x_eq = prove(mk_eq (x_tm, x_vec),
		   REWRITE_TAC[CART_EQ; M_taylor.dimindex_array.(n); M_taylor.gen_in_interval n; comp_th]) in
  let sub_th = GEN_REWRITE_RULE LAND_CONV [x_eq] (UNDISCH (SPEC x_tm (REWRITE_RULE[SUBSET] sub_th0))) in
  let sub_th1 = REWRITE_RULE[IN_INTERVAL; M_taylor.dimindex_array.(n); M_taylor.gen_in_interval n] sub_th in
  let interval_ths = REWRITE_RULE[comp_th; GSYM interval_arith] sub_th1 in
  let vars = map (fun th ->
		    let tm, _ = dest_interval_arith (concl th) in tm, th) 
    (CONJUNCTS interval_ths) in
    dom_tm, vars;;

(**************)

let s_tm, vars = create_domain list1 list2;;

let t1 = `mk_tform ((\x:real^2. x$1 + x$2),
		    [(\x. x$1), e1, ipow2 (-- &10);
		     (\x. x$2), e2, ipow2 (-- &12)])`;;

let a1' = mk_fthm ([], (mk_comb (`approx s (\x:real^2. x$1 + x$2)`, t1)));;
let a1 = INST[s_tm, `s:real^2->bool`] a1';;

(**************)

let mk_ipow2 =
  let ipow2_const = `ipow2` in
    fun n ->
      let n_tm = mk_intconst n in
	mk_comb (ipow2_const, n_tm);;

let dest_mk_tform tm =
  match tm with
    | Comb (Const ("mk_tform", _), p_tm) ->
	dest_pair p_tm
    | _ -> error "dest_mk_tform" [tm] [];;

let dest_approx tm =
  match tm with
    | Comb (Comb (Comb (Const ("approx", _), s_tm), h_tm), mk_tm) ->
	s_tm, h_tm, dest_mk_tform mk_tm
    | _ -> error "dest_approx" [tm] [];;

let dest_f1_list tm =
  let el_tms = dest_list tm in
    map (fun tm ->
	   let tm1, rtm = dest_pair tm in
	   let tm2, tm3 = dest_pair rtm in
	     tm1, tm2, tm3) el_tms;;

let find_max_ipow2 tm =
  let _, _, (_, list_tm) = dest_approx tm in
  let e2_tms = map (fun (_, _, tm) -> tm) (dest_f1_list list_tm) in
  let ints = map (fun tm -> dest_intconst (rand tm)) e2_tms in
    if ints = [] then
      Int 0
    else
      itlist max_num (tl ints) (hd ints);;



let lemma1 = prove
  (`!n. a = ipow2 n * (a * ipow2 (--n))`,
   REWRITE_TAC[REAL_MUL_AC; GSYM ipow2_sub; INT_SUB_REFL; ipow2_0; REAL_MUL_RID]);;

let lemma2 = prove
  (`interval_arith x (lo, hi) /\ a <= ipow2 n * x /\ hi <= b
     ==> a <= b * ipow2 n`,
   REWRITE_TAC[interval_arith] THEN STRIP_TAC THEN
     ONCE_REWRITE_TAC[REAL_MUL_AC] THEN
     MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `ipow2 n * x` THEN
     ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LE_LMUL THEN
     ASM_SIMP_TAC[ipow2_pos; REAL_LT_IMP_LE] THEN ASM_ARITH_TAC);;


let i = find_max_ipow2 (concl a1);;
let i_tm = mk_ipow2 i;;

let th1 = MATCH_MP tform_f1_bound a1;;
let th2 = (UNDISCH_ALL o SPEC_ALL) th1;;
let sum_tm = rand (concl th2);;
let conv1 = REWRITE_CONV[list_mk; sum_list_cons; sum_list_nil; REAL_ADD_RID];;
let conv2 = ONCE_REWRITE_CONV[SPEC (mk_intconst i) lemma1];;
let conv3 = REWRITE_CONV[REAL_ADD_RDISTRIB; GSYM REAL_MUL_ASSOC; GSYM ipow2_add];;
let conv4 = REWRITE_CONV[ipow2_0; REAL_MUL_LID; REAL_MUL_RID; REAL_ADD_RID; REAL_ADD_LID];;

let eq1_th = (conv1 THENC conv2 THENC conv3 THENC INT_REDUCE_CONV THENC conv4) sum_tm;;
let expr_tm1 = rand (rand (concl eq1_th));;

let conv5 = REWRITE_CONV[ipow2_pos_num; ipow2_neg_num];;
let eq2_th = conv5 expr_tm1;;
let eq_th = GEN_REWRITE_RULE (RAND_CONV o RAND_CONV) [eq2_th] eq_th;;
let expr_tm2 = rand (concl eq2_th);;

let ifun = build_interval_fun expr_tm2;;

let expr_interval = eval_interval_fun pp ifun vars [];;

let r1 = expr_interval;;
let r2 = REWRITE_RULE[eq_th] th2;;
let r3 = SPEC (rand (rand (concl r1))) REAL_LE_REFL;;

let t1 = CONJ r1 (CONJ r2 r3);;
MATCH_MP lemma2 t1;;


